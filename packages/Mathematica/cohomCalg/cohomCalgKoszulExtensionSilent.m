(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)


(*------------------------------------------------------------------------------------------------------------------------*)
(*------------------------------------------------------------------------------------------------------------------------*)
(*--                                                                                                                    --*)
(*--                                                                                                                    --*)
(*--                                                                                                                    --*)
(*--                                        ---- cohomCalg ++Koszul extension v0.31 ----                                --*)
(*--                                                                                                                    --*)
(*--                                                 author: Thorsten Rahn                                              --*)
(*--                               Comments, bugs and questions: thorsten.rahn@gmail.com                                --*)
(*--                                           author cohomCalg: Benjamin Jurke                                         --*)
(*--                                                   mail@bjurke.net                                                  --*)
(*--                                                                                                                    --*)
(*--                                 related to and presented in arXiv:1010.3717                                       --*)
(*--                        Ralph Blumenhagen, Benjamin Jurke, Thorsten Rahn, Helmut Roschy                             --*)
(*--                                                                                                                    --*)
(*--                                                                                                                    --*)
(*--                                                                                                                    --*)
(*--                                                                                                                    --*)
(*------------------------------------------------------------------------------------------------------------------------*)
(*------------------------------------------------------------------------------------------------------------------------*)


(*----------------------------------------------------------------------------------------------------------*)
(*                                                    Input required                                        *)
(*----------------------------------------------------------------------------------------------------------*)
(*Pleas fill in the Location of cohomCalg executable*)
(*
For instance on a Windows computer type something like: 
cohomCalgPath="C:\\Program Files\\Mathematica Notebooks\\";
If your Mathematica notebook is in  the same directory as the cohomCalg executible than use the default input*)
(*Default*)
cohomCalgPath=DirectoryName[$InputFileName];
(*Pleas fill in the name of the executable e.g. "cohomcalg.exe" for Windows and "./cohomcalg" for Linux*)
(*Default for Windows*)
cohomCalgExecutable=cohomCalgPath<>"/cohomcalg";
(*----------------------------------------------------------------------------------------------------------*)
(*                                                   End of Input                                           *)
(*----------------------------------------------------------------------------------------------------------*)





(*Setting directory...*)
(*SetDirectory[cohomCalgPath];*)
WorkingPath=cohomCalgPath;
IntermediateName="cohomCalgKoszulExtensionSilent";
If[!DirectoryQ[WorkingPath<>"/"<>IntermediateName<>"_cohomCalg"],CreateDirectory[WorkingPath<>"/"<>IntermediateName<>"_cohomCalg"]];
SetDirectory[WorkingPath<>"/"<>IntermediateName<>"_cohomCalg"];
(*Generate temp file for more efficent calculations*)
TempFile=FileNameJoin[StringJoin[{IntermediateName<>".in"}]];

stream1=OpenWrite[TempFile];
Close[stream1];
(*This file contains the monomial data and is deleted once you choose a different ambient space*)
MonomFile=StringJoin[TempFile,".monoms"];

ResetGlobalVariables:=Module[{},
(*Global Variables*)
LineBundleCounter={0,0,0,0};           (*Contains the number of line bundles calculated and needed for statistics*)
LineBundleList={{"LineBundleList"}};                    (*Contains all line bundles and their cohomologies that have been calculated as long as you don't change the ambient space*)
KoszuledLineBundleList={{1}};(*Contains all line bundles and their cohomologies for a specific subvariety that have been calculated as long as you dont change the ambient space*)
Index=1;                                                    (*Index used to mark the parameters that appear in the long exact sequences*)
SearchForTwisted=0;                        (*If on,it tells you if there are linebundle cohomology contibutions that are not h^0 or h^n and marks them in the final result*)
ShowLongExactSequences=0;           (*If on, all long exact sequences are printed explicitly*)
LESFontSize=18;
cohomCalgLogo=Image[CompressedData["
1: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
x/8Bt81LZw==
"], "Byte", ColorSpace -> "RGB", ImageSize -> {182.62337147700916`, Automatic}, Interleaving -> True];
(*Calculation of bundles of line bundles *)
BundleNumber=1000;
];
 ResetGlobalVariables;
ClearLineBundles:=Module[{i},KoszuledLineBundleList={{1}};LineBundleList={{1}}];

(*----------------------------- Start Usefull additional routines -----------------------------*)
(*WPS Generator*)
WP[Eqrel_]:=Module[{Vars},
Vars=Array[StringJoin[ToString[x],ToString[#]]&,Length[Eqrel]];
Return[{Vars,{Vars},Map[{#}&,Eqrel]}]
]

(*Products of WPS Generator*)
PWPS[Eqrels_,Projective_:"Weighted Projective"]:=Module[{i,j,Vars={},SR={},Counter=1,EqrelsOut},
If[Projective=="Projective",
For[i=1,i<= Length[Eqrels],i++,
Vars=Join[Vars,Array[StringJoin["x",ToString[i],ToString[#]]&,Eqrels[[i]]]];
AppendTo[SR,Array[StringJoin["x",ToString[i],ToString[#]]&,Eqrels[[i]]]];
];
EqrelsOut=Array[0&,{Length[Vars],Length[Eqrels]}];
For[i=1,i<=Length[Eqrels],i++,
For[j=1,j<=Eqrels[[i]],j++,
EqrelsOut[[Counter,Length[Eqrels]+1-i]]=1;
Counter++;
];
];
];
Return[{Vars,SR,EqrelsOut}];
];


(*Hyper surface generator*)
CYHyperSurface[Variety_]:=Module[{i,Hypersurface=Array[0&,Length[Variety[[3,1]]]]},For[i=1,i<=Length[Variety[[3]]],i++,Hypersurface=Hypersurface+Variety[[3,i]]];Return[Hypersurface]];

(*Convers the Triangulizer integrated output to cohomCalg input*)
TriangulizerTocohomCalg[TriangulizerData_]:=Module[{i,j,cohomCalgInput={}},
For[i=1,i<=Length[TriangulizerData]-4,i++,
AppendTo[cohomCalgInput,{TriangulizerData[[2]],Map[Variables[#]&,TriangulizerData[[4+i,2]]],TriangulizerData[[4,2;;Length[TriangulizerData[[4]]]]]}]
];
Return[cohomCalgInput]
];
(*----------------------------- End Usefull additional routines -----------------------------*)


(*Simple check whether the input data is typed in correctly in the right form*)
CheckInputData[AmbientSpace_,ComplInters_,Type_]:=Module[{i,j,NumberOfCharges,CalculationStop},

(*Return[{True,""}];*)
CalculationStop="---> Calculation canceled <---";
(*cohomCalg executable in the correct directory?*)
If[!FileExistsQ[cohomCalgExecutable],Print["File \"",StringJoin[cohomCalgPath,cohomCalgExecutable],"\" not found. Check cohomCalgPath and cohomCalgExecutable variables."];Return[{False,CalculationStop}]];

(*Correct number of entries in Ambientspace?*)
If[Length[AmbientSpace]!=3,Print["Invalid Input Data: Specification of the ambient space not corret"];Return[{False,CalculationStop}]];

(*Correct number of coordinates / GLSM relations?*)
If[AmbientSpace[[1]]!=AmbientSpace[[3]],
Print["Invalid Input Data: The number of coordinates does not match the number of GLSM relations"];
Return[{False,CalculationStop}]];
NumberOfCharges=Length [AmbientSpace[[3,1]]];
For[i=2,i<=Length[AmbientSpace[[3]]],i++,
If[Length[AmbientSpace[[3,i]]]!=NumberOfCharges,
Print["Invalid Input Data: The GLSM specifications are not of unique length"];
Return[{False,CalculationStop}]
];
If[!ListOrLineBundleCohomologyOf[AmbientSpace,Array[0&,Length[AmbientSpace[[3,1]]]]][[1]],Return[{False,CalculationStop}]];
];


(*Correct "type" specification?*)
If[Type!="Calabi-Yau" && Type!= "Kahler" && Type!= "K\[ADoubleDot]hler" && Type!= "Kaehler" &&  Type!="Complex" && Type!="Unknown"&&Type!="Stable",
Print["Invalid Input Data: Specification \"",Type,"\" is not one of the valid types \"Calabi-Yau\", \"Kahler\", \"Complex\", \"Stable\" or \"Unknown\".\n Calculation continued with type \"Unknown\"..."];
];


(*Correct structure of the list of divisors specifying the complete intersection?*)
(*It is either empty or of depth 3*)
If[ComplInters!={},
If[Depth[ComplInters]!= 3,Print["Invalid Input Data: The list depth of the complete intersection not corret"];Return[{False,CalculationStop}]];
(*Number of charges of all divisors of the complete intersection correct?*)
For[i=1,i<=Length[ComplInters],i++,
If[Length[ComplInters[[i]]]!=NumberOfCharges,Print["Invalid Input Data: The complete intersection contains divisors with a wrong number of charges"];Return[{False,CalculationStop}]
];
];
];
Return[{True,""}];
];

(*Generates the matrix reflected at the counter diagonal*)
CounterTranspose[Matrix_]:=Module[{i,j,n,tempmatrix},
tempmatrix= Array[0&,{Length [Matrix[[1,All]]],Length [Matrix[[All,1]]]}];
n=Length[Matrix[[1,All]]];
For[i=1,i<=Length[Matrix[[1,All]]],i++,
For[j=1,j<=Length[Matrix[[1,All]]],j++,
tempmatrix[[i,j]]=Matrix[[n+1-j,n+1-i]]
]
];
Return[tempmatrix];
]

(*Three small routines that convert the Mathematica input to the proper input format of the C++ implementation of cohomCalg *)
(*Converts the variety specifications to the proper string needed by cohomCalg*)
ConvertMathematicaToCppInput[Variety_]:=Module[{i,j,StringVariety},
StringVariety="";
For[i=1,i<=Length[Variety[[1]]],i++,
StringVariety=StringJoin[StringVariety,"vertex ",ToString[Variety[[1,i]]],"|GLSM:(",ListToStringWithoutBracket[Variety[[3,i]]],");"];
];
StringVariety=StringJoin[StringVariety," srideal [",ListToStringWithoutBracket[ReconvertSR[Variety[[2]]]],"];"];
Return[StringVariety];
];
(*Converts a list to as string without the brackets*)
ListToStringWithoutBracket[list_]:=Module[{i,StringList},
StringList=ToString[list[[1]]];
For[i=2,i<=Length[list],i++,
StringList=StringJoin[StringList,",",ToString[list[[i]]]];
];
Return[StringList];
];
(*Converts the SR ideal into the correct cohomCalg input string*)
ReconvertSR[SR_]:=Module[{i,j,StringSR,ListStringSR},
ListStringSR={};
For[i=1,i<=Length[SR],i++,
AppendTo[ListStringSR,ToString[SR[[i,1]]]];
For[j=2,j<=Length[SR[[i]]],j++,
ListStringSR[[i]]=StringJoin[ListStringSR[[i]],"*"];
ListStringSR[[i]]=StringJoin[ListStringSR[[i]],ToString[SR[[i,j]]]];
];
];
Return[ListStringSR];
];

CalculateListOfLineBundles[AmbientSpace_,LineBundleCollector_,NumberOfLineBundles_]:=Module[{i,j,Output,LineBundleCohom,LineBundles,PositionAmbientInList},
(*If[LineBundleList[[1,1]]\[NotEqual] AmbientSpace,If[FileExistsQ[MonomFile],DeleteFile[MonomFile]]];  

If[LineBundleList[[1]]\[NotEqual] AmbientSpace,LineBundleList={AmbientSpace};If[FileExistsQ[MonomFile],DeleteFile[MonomFile]]];  
*)
PositionAmbientInList=Position[LineBundleList,AmbientSpace,{2}];
If[LineBundleList[[1,1]]!=AmbientSpace,If[FileExistsQ[MonomFile],DeleteFile[MonomFile]]];

If[PositionAmbientInList=={},
PrependTo[LineBundleList,{AmbientSpace}];
If[FileExistsQ[MonomFile],DeleteFile[MonomFile]]
]; 
PositionAmbientInList=Position[LineBundleList,AmbientSpace,{2}][[1,1]];
For[i=1,i<=Length[LineBundleCollector],i=i+NumberOfLineBundles,
(*Print[i];*)
If[i+NumberOfLineBundles>Length[LineBundleCollector],
Output=ReadList[GenerateRequestCommand[AmbientSpace,LineBundleCollector[[i;;Length[LineBundleCollector]]]]];
LineBundles=LineBundleCollector[[i;;Length[LineBundleCollector]]];
(*LineBundleCounter[[1]]=LineBundleCounter[[1]]+Mod[Length[LineBundleCollector],NumberOfLineBundles];*)
,
Output=ReadList[GenerateRequestCommand[AmbientSpace,LineBundleCollector[[i;;i+NumberOfLineBundles-1]]]];
LineBundles=LineBundleCollector[[i;;i+NumberOfLineBundles-1]];
(*LineBundleCounter[[1]]=LineBundleCounter[[1]]+NumberOfLineBundles;*)
];
(*Print[GenerateRequestCommand[AmbientSpace,LineBundleCollector[[i;;i+NumberOfLineBundles-1]]]];*)
(*Print[Output];*)
If[Output[[1,1]],
For[j=2,j<=Length[Output[[1]]],j++,
(*Print[{LineBundles[[j-1]],Output[[1,j,1]]}];*)
AppendTo[LineBundleList[[PositionAmbientInList]],{LineBundles[[j-1]],Output[[1,j,1]]}];
];
,
(*Print["cohomCalg Error: " ,Output[[1,2,1]]];*)
LineBundleCohom=Array[False&,Length[AmbientSpace[[1]]]-Length[AmbientSpace[[3,1]]]+1]
];
out=StringJoin["---> ",ToString[LineBundleCounter[[1]]]," different linebundle cohomologies calculated via --cohomCalc-- <---"];
NotebookDelete[temp];
temp=""(*PrintTemporary[out]*)
];

];

(*Routine that puts calculated line bundles in a list for later use of the same ambient variety*)
ListOrLineBundleCohomologyOf[AmbientSpace_,LineBundle_(*,EquivariantCalculation_:False*)]:=Module[{i,j,PositionLinebundleInList,LineBundleCohom,SearchSucceeded,TwistedPositions,NumberArray,Output,SplitedResult,DenominatorElement,CohomologyPosition,CohomologyFactor,SplitContriubution,PositionAmbientInList},
(*LineBundleList*)
(*Check if calculations have been performed before*)

PositionAmbientInList=Position[LineBundleList,AmbientSpace,{2}];
If[LineBundleList[[1,1]]!=AmbientSpace,If[FileExistsQ[MonomFile],DeleteFile[MonomFile]]];

If[PositionAmbientInList=={},
PrependTo[LineBundleList,{AmbientSpace}];
If[FileExistsQ[MonomFile],DeleteFile[MonomFile]]
]; 

PositionAmbientInList=Position[LineBundleList,AmbientSpace,{2}][[1,1]];

PositionLinebundleInList=Position[LineBundleList[[PositionAmbientInList]],LineBundle,{2}];

If[PositionLinebundleInList!={},
LineBundleCounter[[2]]++;
LineBundleCohom=LineBundleList[[PositionAmbientInList]][[PositionLinebundleInList[[1,1]],2]];
,
(*else*)
LineBundleCounter[[1]]++;
LineBundleCounter[[2]]++;
(*Print[GenerateRequestCommand[AmbientSpace,LineBundle]];*)
(*LineBundleCounter[[3]]++;*)
If[!LineBundleCollector[[1]],
Output=ReadList[GenerateRequestCommand[AmbientSpace,{LineBundle}]];
(*Print[Output];*)
(*Print[Map[Position[ToExpression[AmbientSpace[[1]]],#][[1,1]]&,DenominatorElement]];*)
If[Output[[1,1]],LineBundleCohom=Output[[1,2,1]],
Print["cohomCalg Error: " ,Output[[1,2,1]]];
LineBundleCohom=Array[False&,Length[AmbientSpace[[1]]]-Length[AmbientSpace[[3,1]]]+1]
];
If[EquivariantCalculation,
SplitedResult={Array[0&,Length[LineBundleCohom]],Array[0&,Length[LineBundleCohom]]};
For[i=1,i<=Length[Output[[1,2,2]]],i++,
DenominatorElement=Variables[Output[[1,2,2,i,2]]];
(*Print[DenominatorElement];*)
CohomologyPosition=Output[[1,2,2,i,1]]+1;
CohomologyFactor=Output[[1,2,2,i,2]]/Product[DenominatorElement[[j]],{j,1,Length[DenominatorElement]}];
(*DenominatorElement=Variables[Output[[1,2,2]]];*)
SplitContriubution=InvariantAndNonivariantParts[LineBundle,DenominatorElement,AmbientSpace,ZnAction];
SplitedResult[[1,CohomologyPosition]]=SplitedResult[[1,CohomologyPosition]]+SplitContriubution[[1]];
SplitedResult[[2,CohomologyPosition]]=SplitedResult[[2,CohomologyPosition]]+SplitContriubution[[2]];
];
(*Print[SplitedResult];*)
(*Return[{LineBundleCohom,SplitedResult}];*)
Return[SplitedResult[[1]]];
];


AppendTo[LineBundleList[[PositionAmbientInList]],{LineBundle,LineBundleCohom}];
out=StringJoin["---> ",ToString[LineBundleCounter[[1]]]," different linebundle cohomologies calculated via --cohomCalc-- <---"];
NotebookDelete[temp];
temp=""(*PrintTemporary[out]*)
,
(*else if collecotor is turned on:*)
AppendTo[LineBundleCollector,LineBundle];
Return[Array[0&,Length[AmbientSpace[[1]]]-Length[AmbientSpace[[3,1]]]+1]];
];

];
(*Keep in mind from which part of the cohomology of the line bundle on the ambient space the contribution comes by multiplying with the corresponding power of Pi*)
If[SearchForTwisted==1,
For[i=1,i<=Length[LineBundleCohom],i++,
LineBundleCohom[[i]]=LineBundleCohom[[i]]*Power[Pi,i-1];
];
];
Return[LineBundleCohom]
];

(*Subroutine: Generates the expression u1\[GreaterEqual]0 && u2\[GreaterEqual]0 && u3\[GreaterEqual]0 && ... from a given set of coordinates {u1,u2,u3,...}*)
ListElementsLargerEqZero[list_]:=Module[{i,temp},
If[list!= {},temp=list[[1]]>= 0,Return[{}]];
For[i=2,i<=Length[list],i++,
temp=temp && list[[i]]>= 0
];
Return[temp]
];

(*Main counting routing: It generates the matrix m, the constant vector b and solves the linear equations m.x=b for non negative integers*)
InvariantAndNonivariantParts[LineBundle_,DenominatorElement_,AmbientSpace_,ZnAction_]:=Module[{i,j,b,m,ConvertedElement,equrel,coordinates,ResultMonomials,SignVector,Monomials,ActionOnMonomials,DenominatorMonomial,ActionDenominatorMonomial,ModifiedMonomials,ModifiedActionOnMonomials,Invariant,NonInvariant},
(*convert a set of coordinates into their positions in the coordinate-list, e.g. {u1,u2} \[Rule] {1,2}*)
ConvertedElement=Map[Position[ToExpression[AmbientSpace[[1]]],#][[1,1]]&,DenominatorElement];(*ConvertDenominatiorElement[DenominatorElement];*)

coordinates=ToExpression[AmbientSpace[[1]]];
equrel=Transpose[AmbientSpace[[3]]];
m=equrel;
For[i=1,i<=Length[equrel],i++,
For[j=1,j<=Length[equrel[[1]]],j++,
If[MemberQ[ConvertedElement,j],
m[[i]][[j]]=-equrel[[i]][[j]],
(*else*) 
m[[i]][[j]]=equrel[[i]][[j]]
];
];
];
b=Array[-Sum[m[[#]][[j]],{j,ConvertedElement}]&,Length[LineBundle]]+LineBundle;
(*Print[MatrixForm[m.coordinates==b]];*)
ResultMonomials=Reduce[m.coordinates==b&&ListElementsLargerEqZero[coordinates],coordinates,Integers];
ResultMonomials=BooleanConvert[ResultMonomials||{"dummy"}];
(*Checker=ResultMonomials;*)

(*ResultMonomials=Sort[ResultMonomials,1];*)
ResultMonomials=Map[Sort[#]&,ResultMonomials];

(*Print[DenominatorElement,",",ConvertedElement];*)
SignVector=Array[1&,Length[coordinates]];
(**)
SignVector[[ConvertedElement]]=-1;
(*Print[SignVector];*)
If[Length[ResultMonomials]==2,
Monomials={Product[ResultMonomials[[1,a,1]]^(ResultMonomials[[1,a,2]]*SignVector[[a]]),{a,1,Length[ResultMonomials[[1]]]}]};
(*ZnActionAppliesToVariables={1};
ZnAction={-Subscript[x, 1]};*)
ActionOnMonomials={Product[(ZnAction[[Position[coordinates,ResultMonomials[[1,a,1]]][[1,1]]]])^(ResultMonomials[[1,a,2]]*SignVector[[a]]),{a,1,Length[ResultMonomials[[1]]]}]},
(*else*)
Monomials=Map[
Product[#[[a,1]]^(#[[a,2]]*SignVector[[a]]),{a,1,Length[ResultMonomials[[1]]]}]&,ResultMonomials[[1;;Length[ResultMonomials]-1]]];
(*Print[Monomials];*)
(*ZnActionAppliesToVariables={1};
ZnAction={-Subscript[x, 1]};*)
(*ActionOnMonomials=Map[
(*Product[#[[a,1]]^#[[a,2]],{a,1,Length[ResultMonomials[[1]]]}]/Product[#[[a,1]]^#[[a,2]],{a,ZnActionAppliesToVariables}]**)
Product[ZnAction[[a]]^(#[[a,2]]*SignVector[[a]]),{a,Array[#&,Length[coordinates]]}]&,ResultMonomials[[1;;Length[ResultMonomials]-1]]];*)
ActionOnMonomials=Map[
(*Product[#[[a,1]]^#[[a,2]],{a,1,Length[ResultMonomials[[1]]]}]/Product[#[[a,1]]^#[[a,2]],{a,ZnActionAppliesToVariables}]**)
Product[(ZnAction[[Position[coordinates,#[[a,1]]][[1,1]]]])^(#[[a,2]]*SignVector[[a]]),{a,1,Length[ResultMonomials[[1]]]}]&,ResultMonomials[[1;;Length[ResultMonomials]-1]]];
];
(*Print[ZnAction[[1]]*ResultMonomials[[8,1,1]],"^",(ResultMonomials[[8,1,2]]*SignVector[[1]])];
Print[Monomials,"\n",ActionOnMonomials];*)

(*We still need to take the denominator element into account*)
DenominatorMonomial=Product[DenominatorElement[[i]],{i,Length[DenominatorElement]}];
(*Perform the action on the denominator element*)
ActionDenominatorMonomial=Product[ZnAction[[Position[coordinates,DenominatorElement[[i]]][[1,1]]]],{i,Length[DenominatorElement]}];
(*Print[Monomials,"\n"];*)
(*Print[Monomials];*)
Monomials=Map[#/DenominatorMonomial&,Monomials];
(*Print[Monomials];*)
ActionOnMonomials=Map[#/ActionDenominatorMonomial&,ActionOnMonomials];

(*Print["Action Monoms: ",ActionOnMonomials];*)
ModifiedMonomials=Array[Monomials[[#]]&,Length[Monomials]];
ModifiedActionOnMonomials=Flatten[Array[ActionOnMonomials[[#]]&,Length[ActionOnMonomials]]];
(*Print[Length[ModifiedActionOnMonomials]];*)
(*ModifiedMonomials-ModifiedActionOnMonomials;*)
Invariant=Count[ModifiedMonomials-ModifiedActionOnMonomials,0];
(*=Count[ModifiedMonomials-ModifiedActionOnMonomials,0];*)
NonInvariant=Length[ModifiedMonomials]-Invariant;
(*Print[DenominatorMonomial];*)
If[Verbose6,
Print["LineBundle: ",LineBundle,"    Denominator: ",DenominatorElement];
(*Print["Result Monoms: ",ResultMonomials];*)
Print["Laurent monomials: ",ModifiedMonomials,"\n Action Laurent monomials: ",ModifiedActionOnMonomials,"\n Monoms-ActionMonoms: ",ModifiedMonomials-ModifiedActionOnMonomials];
(*Print["Laurent monomials: ",ModifiedMonomials,"Action Laurent monomials: ",ModifiedActionOnMonomials,"    Monoms-ActionMonoms: ",ModifiedMonomials-ModifiedActionOnMonomials];*)
];
Representatives=ModifiedMonomials;
(*Print[EquivariantCalculation];
Print["Invariant = ",Invariant," and non-invariant = ",NonInvariant];*)
Return[{Invariant,NonInvariant}]
];


(*Interface to the cohomCalg C++ Implementation. In and output are the same as in the first Mathematica implementation of cohomCalg*)
LineBundleCohomologyOf[AmbientSpace_,LineBundle_]:=Module[{i},
Return[ListOrLineBundleCohomologyOf[AmbientSpace,LineBundle]]
];
(*Generates the requested command for a given variety and line bundle*)
GenerateRequestCommand[AmbientVariety_,LineBundles_]:=Module[{i,j,command,StringAmbientVariety,StingLineBundle},
StringAmbientVariety= ConvertMathematicaToCppInput[AmbientVariety];
command=StringJoin["!",cohomCalgExecutable," --integrated --in=\" ",StringAmbientVariety];

For[j=1,j<=Length[LineBundles],j++,
StingLineBundle=ToString[LineBundles[[j,1]]];
For[i=2,i<=Length[LineBundles[[j]]],i++,
StingLineBundle=StringJoin[StingLineBundle,",",ToString[LineBundles[[j,i]]]];
];
command=StringJoin[command," ambientcohom O(",StingLineBundle,"); "];
];
command=StringJoin[command,"\" ",TempFile];
Return[command];
];

(*From a short exact sequence of bundles one can obtain a long exact in cohomology. This routine serves to calculate the third cohomology vector of such a scenario. The input data are the two given vectors in the correct order as well as the position of the third requested vector. The fourth variable is the dimension of the requested cohomology vector and in the last one one can include known data from the requested cohomology vector. For instance if one knows that the first entry of that vector is zero one can type {{1,0}}. If nothing is known one needs to type {}. The routine returns the most general result one can get, only using that the long sequence is exact and without taking into account how the maps look like.*)
ThirdVectorFromLongExactSequence[CohomVector1_,CohomVector2_,RequestedVectorPosition_,RequestedVectorDimension_,Retrictions_]:=Module[{i},
(*Only resolve sequences if program does not collect line bundles*)
If[!LineBundleCollector[[1]],

Return[ThirdVectorFromLongExactSequenceLabeled[{CohomVector1,"Vector 1"},{CohomVector2,"Vector 2"},"Result",RequestedVectorPosition,RequestedVectorDimension,Retrictions]],
(*else if line bundles are only collected*)
Return[Array[0&,Length [CohomVector1]]]
]
];


(*Here we can add labels to the column*)
ThirdVectorFromLongExactSequenceLabeled[{CohomVector1_,Label1_},{CohomVector2_,Label2_},Label3_,RequestedVectorPosition_,RequestedVectorDimension_,Retrictions_]:=
Module[{i,j,EquationsToSolve,TempAltersum,LongExactSequence,PositionList,SolutionVector,Solution,ParameterVector,WorkingVector,LongExactSequenceTable,SolutionTable,Labels},

(*Only resolve sequences if program does not collect line bundles*)
If[!LineBundleCollector[[1]],

(*Vector of parameters that will be constraint by altering sums in the long exact sequence*)
(*The index grows with every request in order avoid using the same parameters in different tasks*)
ParameterVector=Array[Subscript[A, Index+#-1]&,Length [CohomVector1]];

(*This vector is for working and has therefore the same length of all the other vectors involved. It will be solved for the h^* and be returned afterwards*)
WorkingVector=Array[Subscript[h, #-1]&,Length [CohomVector1]]; 

(*Put parameters, higher than the requested dimension, to zero*)
For[i=RequestedVectorDimension+2,i<= Length[CohomVector1],i++,ParameterVector[[i]]=0];
(*Takes the parts of the result that are already known into account*)
For[i=1,i<= Length[Retrictions],i++,ParameterVector[[Retrictions[[i,1]]]]=Retrictions[[i,2]]];

(*Put the requested vector in the right position of the sequence*)
If[RequestedVectorPosition==1,LongExactSequence=Transpose[{ParameterVector,CohomVector1,CohomVector2}];Labels={Label3,Label1,Label2}];
If[RequestedVectorPosition==2,LongExactSequence=Transpose[{CohomVector1,ParameterVector,CohomVector2}];Labels={Label1,Label3,Label2}];
If[RequestedVectorPosition==3,LongExactSequence=Transpose[{CohomVector1,CohomVector2,ParameterVector}];Labels={Label1,Label2,Label3}];

EquationsToSolve={};
TempAltersum=0;
(*List of positions of zeros in the long exact sequence*)
PositionList=Position[LongExactSequence,0];

(*Go through the long exact sequence and collect shorter exact sequences between their zero entries*)
For[i=1,i<=Length[LongExactSequence],i++,
For[j=1,j<= Length[LongExactSequence[[1]]],j++,
TempAltersum=TempAltersum+Power[-1,i+j]*LongExactSequence[[i,j]];
If[MemberQ[PositionList,{i,j}]||(i==Length[LongExactSequence]&& j== Length[LongExactSequence[[1]]]),
(*If[LongExactSequence[[i,j]]\[NotEqual] 0,*)
AppendTo[EquationsToSolve,{TempAltersum}];
TempAltersum=0
]
]
];

(*Solutions of the equations, given by exact sequences between zeros in the long exact sequence*)
(*Solution=Solve[WorkingVector - ParameterVector\[Equal]0&& EquationsToSolve\[Equal]0,WorkingVector];*)
Solution={Reduce[WorkingVector-ParameterVector==0&&EquationsToSolve==0,WorkingVector]}/.(y__&&z__):>{y,z}/.(x_==y_):>(x->y);
If[Solution=={False},Print["\!\(\*
StyleBox[\"xxxxxxx\",\nFontColor->RGBColor[1, 0, 0]]\)\!\(\*
StyleBox[\" \",\nFontColor->RGBColor[1, 0, 0]]\)\!\(\*
StyleBox[\"LongExactSequence\",\nFontColor->RGBColor[1, 0, 0]]\)\!\(\*
StyleBox[\" \",\nFontColor->RGBColor[1, 0, 0]]\)\!\(\*
StyleBox[\"is\",\nFontColor->RGBColor[1, 0, 0]]\)\!\(\*
StyleBox[\" \",\nFontColor->RGBColor[1, 0, 0]]\)\!\(\*
StyleBox[\"inconsistent\",\nFontColor->RGBColor[1, 0, 0]]\)\!\(\*
StyleBox[\" \",\nFontColor->RGBColor[1, 0, 0]]\)\!\(\*
StyleBox[\"-\",\nFontColor->RGBColor[1, 0, 0]]\)\!\(\*
StyleBox[\" \",\nFontColor->RGBColor[1, 0, 0]]\)\!\(\*
StyleBox[\"Results\",\nFontColor->RGBColor[1, 0, 0]]\)\!\(\*
StyleBox[\" \",\nFontColor->RGBColor[1, 0, 0]]\)\!\(\*
StyleBox[\"may\",\nFontColor->RGBColor[1, 0, 0]]\)\!\(\*
StyleBox[\" \",\nFontColor->RGBColor[1, 0, 0]]\)\!\(\*
StyleBox[\"not\",\nFontColor->RGBColor[1, 0, 0]]\)\!\(\*
StyleBox[\" \",\nFontColor->RGBColor[1, 0, 0]]\)\!\(\*
StyleBox[\"be\",\nFontColor->RGBColor[1, 0, 0]]\)\!\(\*
StyleBox[\" \",\nFontColor->RGBColor[1, 0, 0]]\)\!\(\*
StyleBox[\"trustworthy\",\nFontColor->RGBColor[1, 0, 0]]\)\!\(\*
StyleBox[\" \",\nFontColor->RGBColor[1, 0, 0]]\)\!\(\*
StyleBox[\"xxxxxxx\",\nFontColor->RGBColor[1, 0, 0]]\)"];Solution={}];
(*else*)
(*Print[Solution];*)
WorkingVector=Flatten[WorkingVector/.Solution];
Index=Index+Length [CohomVector1];
(*,(*else*)
];*)

(*Extended Search for twisted*)
If[Position[LongExactSequence,Pi]=={}&&VerboseSearchForTwisted==True,ShowLongExactSequences=0];

(*If requested, the long exact sequence is printed before calculation*)
If[ShowLongExactSequences== 1,
If[FancyOutput!=1,
Print["Long exact sequence: ",MatrixForm[
Transpose[{Join[{Labels[[1]]},Transpose[LongExactSequence][[1]]],Join[{Labels[[2]]},Transpose[LongExactSequence][[2]]],Join[{Labels[[3]]},Transpose[LongExactSequence][[3]]]}]],
"  --> ",Labels[[RequestedVectorPosition]]," = " ,MatrixForm[WorkingVector]],
(*else*)
LongExactSequenceTable=
Text@Grid[Prepend[LongExactSequence,Labels],Background->{None,{Lighter[Yellow,.9],{White,Lighter[Blend[{Blue,Green}],.8]}}},Dividers->{{Darker[Gray,.6],{Lighter[Gray,.5]},Darker[Gray,.6]},{Darker[Gray,.6],Darker[Gray,.6],{False},Darker[Gray,.6]}},Alignment->{Center},(*ItemSize\[Rule]{{10,3,5,5}},*)Frame->Darker[Gray,.6],ItemStyle->14,Spacings->{Automatic,.8}];

SolutionTable=Text@Grid[Prepend[Transpose[{WorkingVector}],{Labels[[RequestedVectorPosition]]}],Background->{None,{Lighter[Yellow,.9],{White,Lighter[Blend[{Blue,Green}],.8]}}},Dividers->{{Darker[Gray,.6],{Lighter[Gray,.5]},Darker[Gray,.6]},{Darker[Gray,.6],Darker[Gray,.6],{False},Darker[Gray,.6]}},Alignment->{Center},(*ItemSize\[Rule]{{10,3,5,5}},*)Frame->Darker[Gray,.6],ItemStyle->14,Spacings->{Automatic,.8}];

Print[LongExactSequenceTable,Style[" \[DoubleLongRightArrow] ",FontSize->30],SolutionTable];
];
];

(*Extended Search for twisted*)
If[Position[LongExactSequence,Pi]=={}&&VerboseSearchForTwisted==True,ShowLongExactSequences=1];
Return[WorkingVector],
(*else if line bundles are only collected*)
Return[Array[0&,Length [CohomVector1]]]
]

]

(*Start*)
Koszul[AmbientSpace_,ComplInters_,LineBundle_]:=Module[{},
Return[ListOrKoszul[AmbientSpace,ComplInters,LineBundle]]
];

(*Routine that uses the Koszul complex in order to calculate the cohomology of a line bundle of a complete intersection via line bundles of the ambient variety. Input data are the ambient variety the complete intersection divisors and the line bundle*)
ListOrKoszul[AmbientSpace_,ComplInters_,LineBundle_]:=Module[{i,j,DimAmbientSpace,DimComplInters,CalculatedLineBundles,SubVarLineBundleCohom,PositionLinebundleInList,NumberOfLineBundlesNeededTmp},

If[KoszuledLineBundleList[[1]]!= {AmbientSpace,ComplInters},KoszuledLineBundleList={{AmbientSpace,ComplInters}}];
PositionLinebundleInList=Position[KoszuledLineBundleList,LineBundle,{2}];
If[PositionLinebundleInList!={},
(*LineBundleCounter[[2]]++;*)
SubVarLineBundleCohom=KoszuledLineBundleList[[PositionLinebundleInList[[1,1]],2]];
(*Print[KoszuledLineBundleList[[PositionLinebundleInList[[1,1]]]]];*)
LineBundleCounter[[2]]=LineBundleCounter[[2]]+KoszuledLineBundleList[[PositionLinebundleInList[[1,1]],3]];
,
(*else*)
(*If ComplInts is empty, the routine returns simply the cohomology of the line bundle on the ambient variety*)
If[ComplInters=={},Return[ListOrLineBundleCohomologyOf[AmbientSpace,LineBundle]]];

DimAmbientSpace=Length[AmbientSpace[[1]]]-Length[AmbientSpace[[3,1]]];
DimComplInters=DimAmbientSpace-Length[ComplInters];

NumberOfLineBundlesNeededTmp=LineBundleCounter[[2]];
(*If[ShowLongExactSequences\[Equal]1,Print[Length[ComplInters]," Koszul Sequences: The following linebundles are calculated"]];*)
CalculatedLineBundles={};
(*Start the recursion*)
SubVarLineBundleCohom=RecursivKoszul[ComplInters,DimAmbientSpace,LineBundle,AmbientSpace,CalculatedLineBundles,1(*RecursionNumber*)];
(*If[ShowLongExactSequences\[Equal]1,Print["The cohomology dimensions of the requested line bundle on the subvariety is given by: ",SubvarietyResult[[1;;DimComplInters+1]]];Print["  "]];*)
NumberOfLineBundlesNeededTmp=LineBundleCounter[[2]]-NumberOfLineBundlesNeededTmp;
(*Print[NumberOfLineBundlesNeededTmp];*)
(*
If[SearchForTwisted\[Equal]2,
If[Length[Position[SubVarLineBundleCohom,A]]\[NotEqual]0,
(*This vector is for working and has therefore the same length of all the other vectors involved. It will be solved for the h^* and be returned afterwards*)
WorkingVector=Array[Subscript[h, #-1]&,Length [SubVarLineBundleCohom]]; 
(*Solutions of the equations, given by exact sequences between zeros in the long exact sequence*)
(*Solution=Solve[WorkingVector - ParameterVector\[Equal]0&& EquationsToSolve\[Equal]0,WorkingVector];*)
Solution={Reduce[WorkingVector-SubVarLineBundleCohom\[Equal]0&&SubVarLineBundleCohom[[2;;3]]\[Equal]0,WorkingVector]}/.(y__&&z__)\[RuleDelayed]{y,z}/.(x_\[Equal]y_)\[RuleDelayed](x\[Rule]y);

(*Print[SubVarLineBundleCohom];
Print[Position[SubVarLineBundleCohom,A]];
Print[Position[SubVarLineBundleCohom,Subscript]];
Print[Delete[SubVarLineBundleCohom,Position[SubVarLineBundleCohom,A]]];*)
Positions=Position[SubVarLineBundleCohom,A];
SubVarLineBundleCohom=SubVarLineBundleCohom/.Subscript\[Rule]Sum;
SubVarLineBundleCohom=SubVarLineBundleCohom/.A\[Rule]0;
(*Print[SubVarLineBundleCohom];*)
(*SubVarLineBundleCohom[[2;;3]]=Array[SubVarLineBundleCohom[[#+1]]*Power[E,1(*#-1*)]&,2(*Length[SubVarLineBundleCohom]*)]*)
(*SubVarLineBundleCohom=Flatten[WorkingVector/.Solution];*)
For[i=1,i\[LessEqual]Length[Positions],i++,
Index++;
SubVarLineBundleCohom[[Positions[[i,1]]]]=SubVarLineBundleCohom[[Positions[[i,1]]]]+Subscript[A, Index];
SubVarLineBundleCohom[[Positions[[i,1]]]]=SubVarLineBundleCohom[[Positions[[i,1]]]]+Subscript[A, Index];
];
];
SubVarLineBundleCohom[[2;;3]]=Array[SubVarLineBundleCohom[[#+1]]*Power[E,#]&,2(*Length[SubVarLineBundleCohom]*)]
];
*)
If[SearchForTwisted==2,
(*Positions=Position[SubVarLineBundleCohom,Pi];
SubVarLineBundleCohom[[2;;2]]=SubVarLineBundleCohom[[2;;2]]/.Pi\[Rule]E;
SubVarLineBundleCohom[[DimComplInters;;DimComplInters]]=SubVarLineBundleCohom[[DimComplInters;;DimComplInters]]/.Pi\[Rule]E^I;*)
(*SubVarLineBundleCohom=Array[SubVarLineBundleCohom[[#]]*Power[E,#-1]&,Length[SubVarLineBundleCohom]];
SubVarLineBundleCohom=Array[SubVarLineBundleCohom[[#]]*Power[E,#-1]&,Length[SubVarLineBundleCohom]];*)
SubVarLineBundleCohom[[1;;2]]=Array[SubVarLineBundleCohom[[#]]&,2];
SubVarLineBundleCohom=Array[SubVarLineBundleCohom[[#]]*Power[E,#-1]&,Length[SubVarLineBundleCohom]];
];

If[!LineBundleCollector[[1]],
AppendTo[KoszuledLineBundleList,{LineBundle,SubVarLineBundleCohom,NumberOfLineBundlesNeededTmp}];
];
];
(*check holomorphic euler characteristic*)
If[CheckEuler&&!LineBundleCollector[[1]],

(*linebdldivisor=Sum[LineBundle[[i]]*PicardGenerator[[i]],{i,1,Length[LineBundle]}];
Print[linebdldivisor];*)

linebdldivisor=ConvertDivisorsToPicardGenerators[AmbientSpace,LineBundle];
(*Print[linebdldivisor];*)
cohomCalgEuler=Sum[SubVarLineBundleCohom[[i]]*Power[-1,i-1],{i,1,Length[SubVarLineBundleCohom]}];

TrueEuler=OutputLineBdlData["subvariety",subvarch,restrictedrules,subvardim,linebdldivisor];
(*Print[TrueEuler];*)
(*Print[SubVarLineBundleCohom];*)
(*Print[cohomCalgEuler];*)
(*
If[!IsCalabiYau[subvarch],Print["The subvariety is not Calabi-Yau!"]];
subvareulerchar=EulerChar[subvarch,restrictedrules];
Print["The Euler characteristic of the subvariety is:  ",subvareulerchar," = ",N[subvareulerchar]];
CoordinateAnalysis[coordinates~Join~addbasedivname,edgevals~Join~addbasedivisor,subvarch,restrictedrules,picardgens,subvardim,1];
*)
(*Print[TrueEuler-cohomCalgEuler];*)
If[TrueEuler-cohomCalgEuler!=0,
(*Print[aaaaaaaaaaaaaaa];*)
(*If[TrackValue,Print["Subvariety: ",eqns," Line Bundle: ",linebdldivisor," = ","   -   Discrepancy in holomorphic Euler characteristic observed: \n cohomCalg: ",cohomCalgEuler," Index Theorem: ",TrueEuler]];*)
TrackValue=False;
];
];

Return[SubVarLineBundleCohom];
]
(*Routine to convert the divisor charges in a base that the holomorphic euler routine can understand*)
GeneratePicardGenerators[AmbientSpace_]:=Module[{i,j,Picards,ToricDivisor,Picard,Sol,PicardGenerators={}},
For[i=1,i<=Length[AmbientSpace[[3,1]]],i++,
ToricDivisor=Array[0&,Length[AmbientSpace[[3,1]]]];
ToricDivisor[[i]]=1;
Picards=Array[Subscript[Picard, #]&,Length [AmbientSpace[[1]]]];
Sol=FindInstance[Sum[Picards[[i]]*AmbientSpace[[3,i]],{i,1,Length[Picards]}]==ToricDivisor,Picards,Integers];
AppendTo[PicardGenerators,ConvertCoordsToDivClasses[(Picards/.Sol)[[1]].AmbientSpace[[1]]]];
];
Return[PicardGenerators];
];
(*Routine to convert the divisor charges in a base that the holomorphic euler routine can understand*)
ConvertDivisorsToPicardGenerators[AmbientSpace_,LineBundle_]:=Module[{i,j,Sol,Picards,Picard,PicardRep},
Picards=Array[Subscript[Picard,#]&,Length[AmbientSpace[[1]]]];
Sol=FindInstance[Sum[Picards[[i]]*AmbientSpace[[3,i]],{i,1,Length[Picards]}]==LineBundle,Picards,Integers];
PicardRep=ConvertCoordsToDivClasses[(Picards/.Sol)[[1]].AmbientSpace[[1]]];
Return[PicardRep];
];

(*Since the number of exact sequences depends on the number of intersecting hypersurfaces, we use a recursion*)
RecursivKoszul[ComplInters_,Dim_,LineBundle_,AmbientSpace_,CalculatedLineBundles_,RecursionNumber_]:=Module[{i,j,DimAmbientSpace,DimComplInters,IntermediateLineBundleCohom,IntermediateLineBundle,IntermediateLineBundleLabel,FinalLineBundleCohom,FinalLineBundle,FinalLineBundleLable,IntermediateSet,ThirdLabel,FinalSet,CalculatedLineBundlesTMP,IntermediateLineBundleCohomArray,LastLabel,SecondLabel,CurrentDim},
CalculatedLineBundlesTMP=CalculatedLineBundles;
DimAmbientSpace=Length[AmbientSpace[[1]]]-Length[AmbientSpace[[3,1]]];
DimComplInters=DimAmbientSpace-Length[ComplInters];

(*Test if we arrived at the firs exact sequence from equation (...) in [...]*)
If[RecursionNumber==Length[ComplInters],
(*The FinalSet is simply the direct sum over all hypersurfaces from which we have to take cohomology*)
FinalSet=Subsets[ComplInters,{RecursionNumber}];
FinalLineBundleCohom=
Sum[ListOrLineBundleCohomologyOf[AmbientSpace,-Sum[FinalSet[[j,i]],{i,Length[FinalSet[[j]]]}]+LineBundle],{j,Length[FinalSet]}];
(*This intermediate set correspond the second part of the firs exact sequence from equation (...) in [...]*)
IntermediateSet=Subsets[ComplInters,{RecursionNumber-1}];
IntermediateLineBundleCohomArray=Array[
{-Sum[IntermediateSet[[#,i]],{i,Length[IntermediateSet[[#]]]}]+LineBundle,ListOrLineBundleCohomologyOf[AmbientSpace,-Sum[IntermediateSet[[#,i]],{i,Length[IntermediateSet[[#]]]}]+LineBundle]}&,Length[IntermediateSet]
];
(*Keep calculated LineBundles in mind in order to print them at the end if requested*)
AppendTo[
CalculatedLineBundlesTMP,
Map[StringJoin[" h_X(",ListToStringWithoutBracket[#[[1]]],") = (",ListToStringWithoutBracket[#[[2]]],")"]&,IntermediateLineBundleCohomArray/.Pi->1]
];
IntermediateLineBundleCohom=Sum[IntermediateLineBundleCohomArray[[j,2]],{j,1,Length[IntermediateLineBundleCohomArray]}];

(*Labels for the long exact sequences*)
IntermediateLineBundleLabel="";
FinalLineBundleLable="";
If[ShowLongExactSequences==1,
IntermediateLineBundle=IntermediateLineBundleCohomArray[[All,1]];
IntermediateLineBundleLabel=GenerateSequenceLabelExtended[{"", ""},IntermediateLineBundle,"X",FancyOutput,3];

(*Same for the other label*)
FinalLineBundle=Array[-Sum[FinalSet[[#,i]],{i,Length[FinalSet[[#]]]}]+LineBundle&,Length[FinalSet]];
FinalLineBundleLable=GenerateSequenceLabelExtended[{"",""},FinalLineBundle,"X",FancyOutput,3];
];

(*Print the line bundle cohomologies in the direct sums*)
If[ShowLongExactSequences==1 && Length[DeleteDuplicates[Flatten[CalculatedLineBundlesTMP]]]>1,Print[
"In the long exact sequences, sums of the following line bundle cohomologies have been calculated:",
Flatten[CalculatedLineBundlesTMP],"\n"]];

(*Calcuating the last missing column in the first exact sequence*)
If[Length[ComplInters]!=1,
CurrentDim=Dim;
If[FancyOutput==1,
LastLabel= Subscript["\[ScriptCapitalI]",Length[ComplInters]-RecursionNumber+1],
LastLabel= StringJoin["I_",ToString[Length[ComplInters]-RecursionNumber+1]]
],
CurrentDim=DimComplInters;
If[FancyOutput==1,
LastLabel=Subscript["\[ScriptCapitalO]","S"][ListToStringWithoutBracket[LineBundle]],
LastLabel=StringJoin["O_S(",ListToStringWithoutBracket[LineBundle],") "]
];
];

Return[ThirdVectorFromLongExactSequenceLabeled[
{FinalLineBundleCohom,FinalLineBundleLable},
{IntermediateLineBundleCohom,IntermediateLineBundleLabel},
LastLabel,3,CurrentDim,{}]],
(*else*)
(*If the first exact squence is not jet reached we end up here*)
(*The second part of the corresponding short exact sequence depends on in which row of (...) in [...] we are and therefore on the RecursionNumber*)
IntermediateSet=Subsets[ComplInters,{RecursionNumber-1}];
IntermediateLineBundleCohomArray=Array[
{-Sum[IntermediateSet[[#,i]],{i,Length[IntermediateSet[[#]]]}]+LineBundle,ListOrLineBundleCohomologyOf[AmbientSpace,-Sum[IntermediateSet[[#,i]],{i,Length[IntermediateSet[[#]]]}]+LineBundle]}&,Length[IntermediateSet]
];

IntermediateLineBundleCohom=Sum[IntermediateLineBundleCohomArray[[j,2]],{j,1,Length[IntermediateLineBundleCohomArray]}];

(*Creat labels for the long exact sequences as above*)
IntermediateLineBundleLabel="";
If[ShowLongExactSequences==1,
IntermediateLineBundle=Array[ -Sum[IntermediateSet[[#,i]],{i,Length[IntermediateSet[[#]]]}]+LineBundle&,Length[IntermediateSet]];
IntermediateLineBundleLabel=GenerateSequenceLabelExtended[{"",""},IntermediateLineBundle,"X",FancyOutput,3];
];

(*Only for the last row in (...) from [...] we have a different labeling*)
If[RecursionNumber==1,
CurrentDim=DimComplInters;
ThirdLabel=GenerateSequenceLabelExtended[{"",""},{LineBundle},"S",FancyOutput,3],
(*StringJoin["h_S(",ListToStringWithoutBracket[LineBundle],") "],*)
CurrentDim=Dim;
AppendTo[
CalculatedLineBundlesTMP,
Map[StringJoin[" O_X(",ListToStringWithoutBracket[#[[1]]],") = (",ListToStringWithoutBracket[#[[2]]],")"]&,IntermediateLineBundleCohomArray/.Pi->1]
];
If[FancyOutput==1,
ThirdLabel= Subscript["\[ScriptCapitalI]",Length[ComplInters]-RecursionNumber+1],
ThirdLabel= StringJoin["I_",ToString[Length[ComplInters]-RecursionNumber+1]]
];
];
If[FancyOutput==1,
SecondLabel= Subscript["\[ScriptCapitalI]",Length[ComplInters]-RecursionNumber],
SecondLabel= StringJoin["I_",ToString[Length[ComplInters]-RecursionNumber]]
];

(*Start of the recursion of this routine with date for the next row counted from the bottom to the top in (...) from [...]*)
Return[
ThirdVectorFromLongExactSequenceLabeled[
{RecursivKoszul[ComplInters,DimAmbientSpace,LineBundle,AmbientSpace,CalculatedLineBundlesTMP,RecursionNumber+1],
SecondLabel(*StringJoin["h_X(I_",ToString[Length[ComplInters]-RecursionNumber],")"]*)},
{IntermediateLineBundleCohom,IntermediateLineBundleLabel},
ThirdLabel,
3,CurrentDim,{}]]
]
]

(*Routine that generates the labels for the long exact sequences*)
(*Make \\oplus commutative*)
SetAttributes[CirclePlus,Flat];
(*As Input is first the heading in both versions, then the line bundle list the letter for the variety. HeadingsOption is for the choice of the heading one wants to have *)
GenerateSequenceLabelExtended[Heading_,InList_,Variety_,Fancy_,HeadingsOption_]:=Module[{i,j,FancyInList,DirectSum,ListWithMulitCounting,PositionTmp},
ListWithMulitCounting={};
If[InList=={},DirectSum="",
For[i=1,i<=Length[InList],i++,
PositionTmp=Position[ListWithMulitCounting,InList[[i]]];
If[PositionTmp!={},
(*Print[PositionTmp];*)
ListWithMulitCounting[[PositionTmp[[1,1]],2]]++
,
AppendTo[ListWithMulitCounting,{InList[[i]],1}]
]
];
If[Fancy==1,
FancyInList={};
For[i=1,i<=Length[ListWithMulitCounting],i++,
If[ListWithMulitCounting[[i,2]]==1,
AppendTo[FancyInList,Subscript[" \[ScriptCapitalO]",Variety][ListToStringWithoutBracket[ListWithMulitCounting[[i,1]]]]],
(*else*)
AppendTo[FancyInList,Superscript[Subscript[" \[ScriptCapitalO]",Variety][ListToStringWithoutBracket[ListWithMulitCounting[[i,1]]]],CirclePlus["",ListWithMulitCounting[[i,2]]]]]
];
];
DirectSum=FancyInList[[1]];
For[i=2,i<=Length[FancyInList],i++,
DirectSum=CirclePlus[DirectSum,FancyInList[[i]]]
],
DirectSum=StringJoin[" O_",Variety,"(",ListToStringWithoutBracket[InList[[1]]],")"];
j=1;
For[i=2,i<=Length[InList],i++,
If[StringLength[DirectSum]>=j*40,DirectSum=StringJoin[DirectSum,"\n"];j++];
DirectSum=StringJoin[DirectSum,StringJoin[" + O_",Variety,"(",ListToStringWithoutBracket[InList[[i]]],")"]]
];
StringJoin[DirectSum," "];
];
];
(*Heading = 0 only returns the standard text heading back *)
If[HeadingsOption==0,
Return[Style[Heading[[2-Fancy]],FontSize->LESFontSize]]
];
(*Heading = 1 returns the standard text Heading together with the list of line bundles corresponding to InList *)
If[HeadingsOption==1,
If[InList=={},
Return[TableForm[
{"",Style[Heading[[2-Fancy]],FontSize->LESFontSize],""},
TableAlignments->Center,TableSpacing->{1}]],
(*else*)
Return[TableForm[
{Style[Heading[[2-Fancy]],FontSize->LESFontSize],DirectSum},
TableAlignments->Center,TableSpacing->{3}]]
];
];
(*Heading = 2 returns the standard text heading together with the a space above and underneath *)
If[HeadingsOption==2,
Return[TableForm[
{"",Style[Heading[[2-Fancy]],FontSize->LESFontSize],""},
TableAlignments->Center,TableSpacing->{1}]]
];
(*Heading = 2 only returns the list of line bundles corresponding to InList *)
If[HeadingsOption==3,
Return[DirectSum];
];
];

(*Main routine*)
CohomologyOf[BundleType_,AmbientSpace_,ComplIntersIn_,Optional1_:"NotNeeded",Optional2_:"NotNeeded",Optional3_:"NotNeeded",Optional4_:"NotNeeded",Optional4_:"NotNeeded"]:=Module[
{i,VerboseLevel,FancyOutput=1,EarlyTime,PossibleOptionalInputs,Type="Unknown",VerboseLevelIn="Verbose0",FancyOutputIn="NbInterface",SearchForTwistedIn=0,OptionalInput,SFT},
(*List of lists of possible optional input strings*)
EarlyTime=DateList[];
PossibleOptionalInputs={
{"Calabi-Yau","K\[ADoubleDot]hler","Kahler","Kaehler","Complex","Unknown","Stable"},
{"Verbose-1","Verbose0","Verbose1","Verbose2","Verbose3","Verbose4","Verbose5","Verbose6","Verbose8","Verbose9","Verbose10"},
{"Terminal","NbInterface","Fancy"}, 
{"SFT=0","SFT=1","SFT=2","SFT=3"},
{"LineBundlesAtOnce"}
};
OptionalInput={Optional1,Optional2,Optional3,Optional4};

(*Collect the optional input*)
For[i=1,i<=4,i++,
If[OptionalInput[[i]]=="NotNeeded",i=5,
(*Print[ToUpperCase[PossibleOptionalInputs],",",ToUpperCase[OptionalInput[[i]]]];*)
If[Position[ToUpperCase[PossibleOptionalInputs],ToUpperCase[OptionalInput[[i]]]]!={},
tmpPosition=Position[ToUpperCase[PossibleOptionalInputs],ToUpperCase[OptionalInput[[i]]]];
(*Print[tmpPosition];*)
If[tmpPosition[[1,1]]==1,Type=PossibleOptionalInputs[[1,tmpPosition[[1,2]]]]];
If[tmpPosition[[1,1]]==2,VerboseLevelIn=PossibleOptionalInputs[[2,tmpPosition[[1,2]]]]];
If[tmpPosition[[1,1]]==3,FancyOutputIn=PossibleOptionalInputs[[3,tmpPosition[[1,2]]]]];
If[tmpPosition[[1,1]]==4,SearchForTwistedIn=ToExpression[PossibleOptionalInputs[[4,tmpPosition[[1,2]]]]]],
(*else*)
Print["~~~~~~~~Error:    \"",OptionalInput[[i]],"\"    is not a valid optional input string. cohomCalg ++Koszul extension will IGNORE it and continue......"];
];
];
];
(*Print[Type," ",VerboseLevelIn," ",FancyOutputIn," ",SearchForTwistedIn];*)

If[FancyOutputIn=="Terminal",FancyOutput=0];
For[i=-1,i<=10,i++,
(*Print[ToUpperCase[VerboseLevelIn],"\[Equal]",ToUpperCase[StringJoin["Verbose",ToString[i]]]];*)
If[ToUpperCase[VerboseLevelIn]==ToUpperCase[StringJoin["Verbose",ToString[i]]],VerboseLevel=i;i=12];
];
If[i==11,Print["Invalid Verbose level. Please choose \"Verbose-1\"-\"Verbose6\".\n Calculation canceled..."];Return[];];
(*Print[ComplIntersIn];*)
LineBundleCounter[[1]]=0;
LineBundleCounter[[2]]=0;

If[BundleType!="EquivariantLineBundle"&&BundleType!="EquivariantCohomology",
(*Start the full program once in order to collect line bundles*)
LineBundleCollector={True};

StartCohomologyOf[False,BundleType,AmbientSpace,ComplIntersIn,Type,(*"Verbose-1"*)-1,(*FancyOutput*)0,(*"SFT=0"*)0,EarlyTime];
(*Calculate all collected line bundles*)
(*Print[LineBundleCollector];*)
LineBundleCollector=DeleteDuplicates[LineBundleCollector];
(*Print[LineBundleCollector];*)
(*Print[LineBundleCollector];*)

LineBundleCollector=Delete[LineBundleCollector,1];
(*Print[LineBundleCollector];*)

LineBundleCounter[[1]]=Length[LineBundleCollector];
LineBundleCounter[[3]]=LineBundleCounter[[3]]+Length[LineBundleCollector];
LineBundleCounter[[4]]=LineBundleCounter[[4]]+LineBundleCounter[[2]];
LineBundleCounter[[2]]=0;

CalculateListOfLineBundles[AmbientSpace,LineBundleCollector,BundleNumber];
(*Print[LineBundleCollector];*)
];

LineBundleCollector={False};
(*KoszuledLineBundleList={{1}}*)

(*Start program again in order to calculate sequences*)

Return[StartCohomologyOf[False,BundleType,AmbientSpace,ComplIntersIn,Type,VerboseLevel,FancyOutput,SearchForTwistedIn,EarlyTime]];
];

StartCohomologyOf[HodgeCalculation_,BundleType_,AmbientSpace_,ComplIntersIn_,Type_,VerboseLevel_,FancyOutputIn_,SearchForTwistedIn_,EarlyTime_:0]:=Module[
{i,j,r,V,ReturnCohomology,PrintCohomology,(*EarlyTime,*)LateTime,DimComplInters,DimAmbientSpace,ComplInters,VectorBundleCharges,VectorBundleConstraints,CheckData,ShowKoszul,ShowLES,LineBundle,
(*Equivariant Line Bundle*)ReturnCohomologyPlus,ReturnCohomologyMinus,
(*Lambda^0 tangent bundle variables*)Lambda0CotangentBundleCohomology,CalabiYauRestrictions,
(*Other Monad Bundle*)DualExactMonadBundleCohomology,
(*Monad bundle variables*)AuxiliaryBundle,CotangentBundelCohomology,EulerBundles11,EulerBundles12,Vector1,Vector2,LabelEuler11,LabelEuler12,LabelEuler13,Euler21Array,Euler21,LabelEuler21,LabelEuler23,VbConstrString,VbChargesString,nV,rV,ShowSpecialLES,HeadingsOption,VBr,lV,Euler11Label,Euler12Label,Euler13Label,ODiDjSubsets,ODiDjArray,ODiDj,ODiDjLabel,Vector2Label,AuxiliaryBundleQ1Label,AuxiliaryBundleQ1,Lambda2AuxiliaryBundleLabel,Lambda2AuxiliaryBundle,OSmSimDk,OSmSimDkSubsets,OSmSimDkArray,Vector2Array,OSmSimDkLabel,TensorProductAuxiliaryBundleLabel,TensorProductAuxiliaryBundle,OSmSimSj,OSmSimSjArray,OSmSimSjLabel,TensorProductOmega1Label,TensorProductOmega1,OSmSimSj2,OSmSimSj2Array,OSmSimSj2Label,AuxBundleQ2Label,AuxBundleQ2,Lambda2OmegaLabel,Lambda2Omega,
(*Tangent bundle variables*)TangentBundelCohomology,
(*Hodge diamond variables*)RowZero,RowOne,RowTwo,ParameterMatrix,WorkingMatrix,WorkingVector,Solution,ResultMatrix,BettiVector,
(*End monad bundle*)OSmMi,OSNrmMi,OSNrmMiArray,OSmMiLabel,OSNrmMiLabel,VBrOSMiArray,ExOSmMiLabel,ExOSmMi,OSmNr,OSmNrLabel,rOSxEdualLabel,rOSxEdual,OSNrmNr, VBrOSNr,OSNrmNrArray,VBrOSNrArray,OSNrmNrLabel,VBrOSNrLabel,OSNrxEdualLabel,OSNrxEdual,OSmNrMi,VBrOSMi,OSmNrMiLabel,VBrOSMiLabel,OSMixEdualLabel,OSMixEdual,Vector1Label,OSMixVdualLabel,OSMixVdual,ExEdualLabel,ExEdual,EdualxE,ParameterVector,ExEdualSFT,ExVdualLabel,ExVdual,VxVdualLabel,VxVdual,Stats},

FancyOutput=FancyOutputIn;
If[SearchForTwistedIn==3,
SearchForTwisted=1;VerboseSearchForTwisted=True,
SearchForTwisted=SearchForTwistedIn;VerboseSearchForTwisted=False
];

r=Length[AmbientSpace[[3,1]]];
ComplInters=ComplIntersIn;

ReturnCohomology={};
ShowKoszul=VerboseLevel==3||VerboseLevel==4||VerboseLevel==5||VerboseLevel==10;
ShowLES=VerboseLevel==1||VerboseLevel==2||VerboseLevel==4||VerboseLevel==5;
DimAmbientSpace=Length[AmbientSpace[[1]]]-Length[AmbientSpace[[3,1]]];

If[VerboseLevel==2||VerboseLevel==5||VerboseLevel==9||VerboseLevel==10,HeadingsOption=1,HeadingsOption=0];
(*Special verbose for showing the critical sequences in EndV*)
ShowSpecialLES=VerboseLevel==8||VerboseLevel==9||VerboseLevel==10;



(*Resest of the counter if there is no hogde diamond calculation going on*)
If[!HodgeCalculation,(*LineBundleCounter={0,0};*)Index=1(*Index is an index for the "ununiqueness constants" in the cohomology vector*)];

(*EquivariantCalculation="EquivariantCalculationOff";*)
If[BundleType=="EquivariantLineBundle"||BundleType=="EquivariantCohomology",

If[Length[ComplInters]!=3,Print["Calculation canceled: Please spectify the \!\(\*SubscriptBox[\(\[DoubleStruckCapitalZ]\), \(n\)]\) action !" ];Return[]];
KoszuledLineBundleList={{1}};
LineBundle=ComplInters[[2]];
ComplInters=ComplIntersIn[[1]];
DimComplInters=DimAmbientSpace-Length[ComplInters];

(*The Z_n action*)
ZnAction=ComplIntersIn[[3]];


If[ShowKoszul,ShowLongExactSequences=1,ShowLongExactSequences=0];
If[VerboseLevel==6,Verbose6=True,Verbose6=False];

ClearLineBundles;

EquivariantCalculation=True;
ReturnCohomologyPlus=Koszul[AmbientSpace,ComplInters,LineBundle][[1;;DimComplInters+1]];
EquivariantCalculation=False;
ClearLineBundles;

FullResult=CohomologyOf["LineBundle",AmbientSpace,{ComplInters,LineBundle},"Verbose-1"];


ReturnCohomologyMinus=FullResult-ReturnCohomologyPlus;

ReturnCohomology={ReturnCohomologyPlus,ReturnCohomologyMinus};
PrintCohomology=TableForm[{
Text@Grid[Prepend[Transpose[{ReturnCohomologyPlus}],{Subsuperscript["h","+","\[Bullet]"][ListToStringWithoutBracket[LineBundle]]}],Background->{None,{Lighter[Yellow,.9],{White,Lighter[Blend[{Blue,Green}],.8]}}},Dividers->{{Darker[Gray,.6],{Lighter[Gray,.5]},Darker[Gray,.6]},{Darker[Gray,.6],Darker[Gray,.6],{False},Darker[Gray,.6]}},Alignment->{Center},(*ItemSize\[Rule]{{10,3,5,5}},*)Frame->Darker[Gray,.6],ItemStyle->14,Spacings->{Automatic,.8}],
Text@Grid[Prepend[Transpose[{ReturnCohomologyMinus}],{Subsuperscript["h","-","\[Bullet]"][ListToStringWithoutBracket[LineBundle]]}],Background->{None,{Lighter[Yellow,.9],{White,Lighter[Blend[{Blue,Green}],.8]}}},Dividers->{{Darker[Gray,.6],{Lighter[Gray,.5]},Darker[Gray,.6]},{Darker[Gray,.6],Darker[Gray,.6],{False},Darker[Gray,.6]}},Alignment->{Center},(*ItemSize\[Rule]{{10,3,5,5}},*)Frame->Darker[Gray,.6],ItemStyle->14,Spacings->{Automatic,.8}]
},TableDirections->Row
];
];

If[BundleType=="LineBundle",
KoszuledLineBundleList={{1}};
LineBundle=ComplInters[[2]];
ComplInters=ComplIntersIn[[1]];
DimComplInters=DimAmbientSpace-Length[ComplInters];

(*Check for correct input data*)
CheckData=CheckInputData[AmbientSpace,ComplInters,Type];
If[!CheckData[[1]],Return[CheckData[[2]]]];

If[ShowKoszul,ShowLongExactSequences=1,ShowLongExactSequences=0];
ReturnCohomology=Koszul[AmbientSpace,ComplInters,LineBundle][[1;;DimComplInters+1]];

PrintCohomology=Text@Grid[Prepend[Transpose[{ReturnCohomology}],{Superscript["h","\[Bullet]"][ListToStringWithoutBracket[LineBundle]]}],Background->{None,{Lighter[Yellow,.9],{White,Lighter[Blend[{Blue,Green}],.8]}}},Dividers->{{Darker[Gray,.6],{Lighter[Gray,.5]},Darker[Gray,.6]},{Darker[Gray,.6],Darker[Gray,.6],{False},Darker[Gray,.6]}},Alignment->{Center},(*ItemSize\[Rule]{{10,3,5,5}},*)Frame->Darker[Gray,.6],ItemStyle->14,Spacings->{Automatic,.8}]
];

(*Distinguish between monad bundles and the tangent bundle. Lambda1CoTM and CoTM are of course the same*)
(*Tangent bundle calculation*)
If[BundleType=="CotangentBundle"||BundleType=="Lambda1CotangentBundle"||BundleType=="Lambda2CotangentBundle"||BundleType=="EndTangentBundle"||BundleType=="Lambda0CotangentBundle"||BundleType=="TangentBundle",
VectorBundleCharges=AmbientSpace[[3]];
VectorBundleConstraints=ComplInters;
VBr=r;
VbConstrString="S";lV="l";
If[FancyOutput==1,V=Subscript["T","S"];VbChargesString="D";nV="n";rV="r",
(*else*) V="TS";VbChargesString="D";nV="n";rV="r"];
];

(*Monad bundle calculation*)
If[BundleType=="DualMonadBundle"||BundleType=="Lambda1DualMonadBundle"||BundleType=="Lambda2DualMonadBundle"||BundleType=="EndMonadBundle"||BundleType=="MonadBundle"||BundleType=="MonadHodgeDiamond",
ComplInters=ComplIntersIn[[1]];
VectorBundleCharges=ComplIntersIn[[2]];
VectorBundleConstraints=ComplIntersIn[[3]];
VBr=ComplIntersIn[[4]];
VbConstrString="M";lV=Subscript["l","V"];
If[FancyOutput==1,V="V";VbChargesString="N";nV=Subscript["n","V"];rV=Subscript["r","V"],
(*else*)
V="V";VbChargesString="N";nV="nV";rV="rV"];
];

(*Monad bundle calculation*)
If[BundleType=="DualExactMonadBundle"||BundleType=="ExactMonadBundle"||BundleType=="Lambda1ExactMonadBundle"BundleType=="Lambda1DualExactMonadBundle"||BundleType=="Lambda2ExactMonadBundle"||BundleType=="Lambda2EMonadBundle",
ComplInters=ComplIntersIn[[1]];
VectorBundleCharges=ComplIntersIn[[2]];
VectorBundleConstraints=ComplIntersIn[[3]];
(*VBr=ComplIntersIn[[4]];*)
VBr=0;
VbConstrString="M";lV=Subscript["l","V"];
If[FancyOutput==1,V="V";VbChargesString="N";nV=Subscript["n","V"];rV=Subscript["r","V"],
(*else*)
V="V";VbChargesString="N";nV="nV";rV="rV"];
];


(*Initialize variables for holomorphic euler check*)
If[!HodgeCalculation&&CheckEuler&&!LineBundleCollector[[1]],

eqns=Map[ConvertDivisorsToPicardGenerators[AmbientSpace,#]&,ComplInters];

subvar=Apply[Times,eqns];
subvardim=ambientdimension-TotalPolyDegree[subvar];
(*TEMPrestrictedintz=PrintTemporary["Computing the restricted intersection numbers..."];*)
restrictedrulz=ComputeRestrictedIntz[rule,picardgens,ambientdimension,subvar];
restrictedrules:=restrictedrulz[[2]];
(*Clear[TEMPrestrictedintz];*)
(*Print["The ",subvardim,"-dimensional subvariety is given by:  ",subvar,"
The restricted intersection numbers on it are:  ",restrictedrules];
Print["The restricted intersection form is:  ",restrictedrulz[[1]]];*)
(*TEMPambientchernclass=PrintTemporary["Computing ambient Chern total class..."];*)
ambientchernclass=FastAmbientTotalChernClassFromCoords[edgevals,ambientdimension];
ambientterms=Length[MonomialList[ambientchernclass]];
(*Clear[TEMPambientchernclass];*)
(*Print["The ambient space total Chern class has ",ambientterms," monomial terms."];*)
subvarch=SubvarietyChernClasses[ambientchernclass,eqns,subvardim];
(*OutputChernClassList[subvarch,"subvariety"];*)
];


(*-----------------------------------------------Start calculation of the O_S  cohomology--------------------------------------------------*)
If[BundleType=="Lambda0CotangentBundle",
KoszuledLineBundleList={{1}};

(*Check for correct input data*)
CheckData=CheckInputData[AmbientSpace,ComplInters,Type];
If[!CheckData[[1]],Return[CheckData[[2]]]];

(*Check if the Hodge diamond is calculated*)
If[!HodgeCalculation,(*LineBundleCounter={0,0};*)Index=1];

DimComplInters=DimAmbientSpace-Length[ComplInters];
Index=1; (*Index is an index for the "ununiqueness constants" in the cohomology vector*)
r=Length[AmbientSpace[[3,1]]];
If[ShowKoszul,ShowLongExactSequences=1,ShowLongExactSequences=0];
(*Calculate O_S*)
Lambda0CotangentBundleCohomology=Koszul[AmbientSpace,ComplInters,Array[0^#&,r]][[1;;DimComplInters+1]];
ReturnCohomology=Lambda0CotangentBundleCohomology;

PrintCohomology=Text@Grid[Prepend[Transpose[{ReturnCohomology}],{Superscript["h","\[Bullet]"][Superscript["\[CapitalLambda]",0][Superscript[V,"*"]]]}],Background->{None,{Lighter[Yellow,.9],{White,Lighter[Blend[{Blue,Green}],.8]}}},Dividers->{{Darker[Gray,.6],{Lighter[Gray,.5]},Darker[Gray,.6]},{Darker[Gray,.6],Darker[Gray,.6],{False},Darker[Gray,.6]}},Alignment->{Center},(*ItemSize\[Rule]{{10,3,5,5}},*)Frame->Darker[Gray,.6],ItemStyle->14,Spacings->{Automatic,.8}]
];
(*-----------------------------------------------End calculation of the O_S  cohomology----------------------------------------------------*)

(*---------------------------------------Start calculation of the exact monad bundle cohomology--------------------------------------------------*)
If[BundleType=="ExactMonadBundle"||BundleType=="Lambda1ExactMonadBundle",
(*Reset list of calculated line bundle cohomologie of the subvariety*)
KoszuledLineBundleList={{1}};
(*Check for correct input data*)
CheckData=CheckInputData[AmbientSpace,ComplInters,Type];
If[!CheckData[[1]],Return[CheckData[[2]]]];

If[!HodgeCalculation,Index=1 (*Index is an index for the "ununiqueness constants" in the cohomology vector*)];
DimAmbientSpace=Length[AmbientSpace[[1]]]-Length[AmbientSpace[[3,1]]];
DimComplInters=DimAmbientSpace-Length[ComplInters];
r=Length[AmbientSpace[[3,1]]];

If[ShowKoszul,ShowLongExactSequences=1,ShowLongExactSequences=0];
EulerBundles11=VectorBundleCharges;
Euler21Array=VectorBundleConstraints;

If[ShowKoszul,ShowLongExactSequences=1,ShowLongExactSequences=0];
Vector1=Sum[Koszul[AmbientSpace,ComplInters,EulerBundles11[[i]]],{i,1,Length[VectorBundleCharges]}];
Euler21=Array[0&,DimAmbientSpace];
Euler21=Euler21+Sum[Koszul[AmbientSpace,ComplInters,Euler21Array[[i]]],{i,1,Length[Euler21Array]}];

If[ShowLES,
LabelEuler21=GenerateSequenceLabelExtended[
(*Heading Fancy*){Subsuperscript["\[CirclePlus]","i=1",lV][Subscript[ "\[ScriptCapitalO]","S"][Subscript[StringJoin["-",VbConstrString],"i"]]],
(*Heading Standard*)StringJoin["\\oplus_i O_S[-",VbConstrString,"_i]"]},
(*InList*)Euler21Array,(*Variety*)"S",(*Fancy*)FancyOutput,(*HeadingsOption*)HeadingsOption];
LabelEuler11=GenerateSequenceLabelExtended[
(*Heading Fancy*){Subsuperscript["\[CirclePlus]","k=1",nV][Subscript[ "\[ScriptCapitalO]","S"][Subscript[StringJoin["-",VbChargesString],"k"]]],
(*Heading Standard*)StringJoin["\\oplus_k O_S[-",VbChargesString,"_k]"]},
(*InList*)EulerBundles11,(*Variety*)"S",(*Fancy*)FancyOutput,(*HeadingsOption*)HeadingsOption];
ShowLongExactSequences=1,ShowLongExactSequences=0
];

DualExactMonadBundleCohomology=ThirdVectorFromLongExactSequenceLabeled[
{Vector1,LabelEuler11},
{Euler21,LabelEuler21},
"V",
1,
DimComplInters,CalabiYauRestrictions
];
ReturnCohomology=DualExactMonadBundleCohomology[[1;;DimComplInters+1]];

PrintCohomology=Text@Grid[Prepend[Transpose[{ReturnCohomology}],{Superscript["h","\[Bullet]"][Superscript[V,"*"]]}],Background->{None,{Lighter[Yellow,.9],{White,Lighter[Blend[{Blue,Green}],.8]}}},Dividers->{{Darker[Gray,.6],{Lighter[Gray,.5]},Darker[Gray,.6]},{Darker[Gray,.6],Darker[Gray,.6],{False},Darker[Gray,.6]}},Alignment->{Center},(*ItemSize\[Rule]{{10,3,5,5}},*)Frame->Darker[Gray,.6],ItemStyle->14,Spacings->{Automatic,.8}]
];
(*-----------------------------------End calculation of the exact monad bundle cohomology--------------------------------------------------*)

(*---------------------------------------Start calculation of the Lambda 2 of the exact dual monad bundle cohomology--------------------------------------------------*)

If[BundleType=="Lambda2ExactMonadBundle"||BundleType=="Lambda2EMonadBundle",
(*Reset list of calculated line bundle cohomologie of the subvariety*)
KoszuledLineBundleList={{1}};
(*Check for correct input data*)
CheckData=CheckInputData[AmbientSpace,ComplInters,Type];
If[!CheckData[[1]],Return[CheckData[[2]]]];

If[!HodgeCalculation,(*LineBundleCounter={0,0};*)Index=1 (*Index is an index for the "ununiqueness constants" in the cohomology vector*)];
DimAmbientSpace=Length[AmbientSpace[[1]]]-Length[AmbientSpace[[3,1]]];
DimComplInters=DimAmbientSpace-Length[ComplInters];
r=Length[AmbientSpace[[3,1]]];


(*Sequence 3*)

If[ShowKoszul,ShowLongExactSequences=1,ShowLongExactSequences=0];
OSmSimDkArray={};
For[i=1,i<= Length[VectorBundleCharges],i++,
For[j=1,j<= Length[VectorBundleConstraints],j++,
AppendTo[OSmSimDkArray,VectorBundleCharges[[i]]+VectorBundleConstraints[[j]]];
];
];

OSmSimDk=Sum[Sum[Koszul[AmbientSpace,ComplInters,VectorBundleConstraints[[i]]+VectorBundleCharges[[j]]],{i,Length[VectorBundleConstraints]}],{j,Length[VectorBundleCharges]}];
(*---*)
OSmSimSj=Array[0^#&,DimAmbientSpace+1];
OSmSimSjArray={};
For[i=1,i<= Length[VectorBundleConstraints],i++,
For[j=1,j<= Length[VectorBundleConstraints],j++,
OSmSimSj=OSmSimSj+Koszul[AmbientSpace,ComplInters,+VectorBundleConstraints[[i]]+VectorBundleConstraints[[j]]];
AppendTo[OSmSimSjArray,VectorBundleConstraints[[i]]+VectorBundleConstraints[[j]]];
];
];

If[ShowLES,
OSmSimDkLabel=GenerateSequenceLabelExtended[
(*Heading Fancy*){Subsuperscript["\[CirclePlus]","i=1",lV]Subsuperscript["\[CirclePlus]","k=1",nV]Subscript[ "\[ScriptCapitalO]","S"][Subscript[VbConstrString,"j"]+Subscript[VbChargesString,"\[Rho]"]],
(*Heading Standard*)StringJoin["\\oplus_i\\oplus_k O_S(-",VbConstrString,"_j-",VbChargesString,"_k)"]},
(*InList*)OSmSimDkArray,(*Variety*)"S",(*Fancy*)FancyOutput,(*HeadingsOption*)HeadingsOption];
OSmSimSjLabel=GenerateSequenceLabelExtended[
(*Heading Fancy*){Subsuperscript["\[CirclePlus]","i=1",lV]Subsuperscript["\[CirclePlus]","j=1",lV][Subscript[ "\[ScriptCapitalO]","S"][Subscript[VbConstrString,"i"]+Subscript[VbConstrString,"j"]]],
(*Heading Standard*)StringJoin["\\oplus_{i,j} O_S(-",VbConstrString,"_i-",VbConstrString,"_j)"]},
(*InList*)OSmSimSjArray,(*Variety*)"S",(*Fancy*)FancyOutput,(*HeadingsOption*)HeadingsOption];
ShowLongExactSequences=1,ShowLongExactSequences=0;
];

VTensorLineBundleSum=ThirdVectorFromLongExactSequenceLabeled[
{OSmSimDk,OSmSimDkLabel},
{OSmSimSj,OSmSimSjLabel},
"V\[CircleTimes]"Subscript["O","s"][Subscript["M","i"]],
1,
DimComplInters,CalabiYauRestrictions
];

(*Sequence 2*)
If[ShowKoszul,ShowLongExactSequences=1,ShowLongExactSequences=0];
OSmSimSj=Array[0^#&,DimAmbientSpace+1];
OSmSimSjArray={};
For[i=1,i<= Length[VectorBundleConstraints],i++,
For[j=1,j<i,j++,
OSmSimSj=OSmSimSj+Koszul[AmbientSpace,ComplInters,+VectorBundleConstraints[[i]]+VectorBundleConstraints[[j]]];
AppendTo[OSmSimSjArray,VectorBundleConstraints[[i]]+VectorBundleConstraints[[j]]];
];
];
OSDiDj=Array[0^#&,DimAmbientSpace+1];
OSDiDjArray={};
For[i=1,i<= Length[VectorBundleCharges],i++,
For[j=1,j<i,j++,
OSDiDj=OSDiDj+Koszul[AmbientSpace,ComplInters,+VectorBundleCharges[[i]]+VectorBundleCharges[[j]]];
AppendTo[OSDiDjArray,VectorBundleCharges[[i]]+VectorBundleCharges[[j]]];
];
];

If[ShowLES,
OSmSimSjLabel=GenerateSequenceLabelExtended[
(*Heading Fancy*){Subsuperscript["\[CirclePlus]","i<j",lV]Subscript[ "\[ScriptCapitalO]","S"][Subscript[VbConstrString,"i"]+Subscript[VbConstrString,"j"]],
(*Heading Standard*)StringJoin["\\oplus_i\\oplus_j O_S(-",VbConstrString,"_i-",VbConstrString,"_j)"]},
(*InList*)OSmSimSjArray,(*Variety*)"S",(*Fancy*)FancyOutput,(*HeadingsOption*)HeadingsOption];
OSDiDjLabel=GenerateSequenceLabelExtended[
(*Heading Fancy*){Subsuperscript["\[CirclePlus]","\[Rho]<\[Rho]'",lV][Subscript[ "\[ScriptCapitalO]","S"][Subscript[VbChargesString,"\[Rho]"]+Subscript[VbChargesString,"\[Rho]'"]]],
(*Heading Standard*)StringJoin["\\oplus_{\rho,\rho'} O_S(",VbChargesString,"_\rho+",VbChargesString,"_\rho')"]},
(*InList*)OSDiDjArray,(*Variety*)"S",(*Fancy*)FancyOutput,(*HeadingsOption*)HeadingsOption];
ShowLongExactSequences=1,ShowLongExactSequences=0;
];

Q1AuxBundle=ThirdVectorFromLongExactSequenceLabeled[
{OSDiDj,OSDiDjLabel},
{OSmSimSj,OSmSimSjLabel},
Subscript["Q",1],
1,
DimComplInters,CalabiYauRestrictions
];

(*Sequence 1*)
Lambda2DualExactMonadBundleCohomology=ThirdVectorFromLongExactSequenceLabeled[
{Q1AuxBundle,"Q1"},
{VTensorLineBundleSum,"V\[CircleTimes]"Subscript["O","s"][Subscript["M","i"]]},
Superscript["\[CapitalLambda]",2][V],
1,
DimComplInters,CalabiYauRestrictions
];


ReturnCohomology=Lambda2DualExactMonadBundleCohomology[[1;;DimComplInters+1]];

PrintCohomology=Text@Grid[Prepend[Transpose[{ReturnCohomology}],{Superscript["h","\[Bullet]"][Superscript["\[CapitalLambda]","2"][V]]}],Background->{None,{Lighter[Yellow,.9],{White,Lighter[Blend[{Blue,Green}],.8]}}},Dividers->{{Darker[Gray,.6],{Lighter[Gray,.5]},Darker[Gray,.6]},{Darker[Gray,.6],Darker[Gray,.6],{False},Darker[Gray,.6]}},Alignment->{Center},(*ItemSize\[Rule]{{10,3,5,5}},*)Frame->Darker[Gray,.6],ItemStyle->14,Spacings->{Automatic,.8}]
];
(*-----------------------------------End calculation of Lambda 2 of the exact monad bundle cohomology--------------------------------------------------*)


(*---------------------------------------Start calculation of the exact dual monad bundle cohomology--------------------------------------------------*)

If[BundleType=="DualExactMonadBundle"||BundleType=="Lambda1DualExactMonadBundle",
(*Reset list of calculated line bundle cohomologie of the subvariety*)
KoszuledLineBundleList={{1}};
(*Check for correct input data*)
CheckData=CheckInputData[AmbientSpace,ComplInters,Type];
If[!CheckData[[1]],Return[CheckData[[2]]]];

If[!HodgeCalculation,(*LineBundleCounter={0,0};*)Index=1 (*Index is an index for the "ununiqueness constants" in the cohomology vector*)];
DimAmbientSpace=Length[AmbientSpace[[1]]]-Length[AmbientSpace[[3,1]]];
DimComplInters=DimAmbientSpace-Length[ComplInters];
r=Length[AmbientSpace[[3,1]]];

If[ShowKoszul,ShowLongExactSequences=1,ShowLongExactSequences=0];
EulerBundles11=-VectorBundleCharges;
Euler21Array=-VectorBundleConstraints;

If[ShowKoszul,ShowLongExactSequences=1,ShowLongExactSequences=0];
Vector1=Sum[Koszul[AmbientSpace,ComplInters,EulerBundles11[[i]]],{i,1,Length[VectorBundleCharges]}];
Euler21=Sum[Koszul[AmbientSpace,ComplInters,Euler21Array[[i]]],{i,1,Length[Euler21Array]}];

If[ShowLES,
LabelEuler21=GenerateSequenceLabelExtended[
(*Heading Fancy*){Subsuperscript["\[CirclePlus]","i=1",lV][Subscript[ "\[ScriptCapitalO]","S"][Subscript[StringJoin["-",VbConstrString],"i"]]],
(*Heading Standard*)StringJoin["\\oplus_i O_S[-",VbConstrString,"_i]"]},
(*InList*)Euler21Array,(*Variety*)"S",(*Fancy*)FancyOutput,(*HeadingsOption*)HeadingsOption];
LabelEuler11=GenerateSequenceLabelExtended[
(*Heading Fancy*){Subsuperscript["\[CirclePlus]","k=1",nV][Subscript[ "\[ScriptCapitalO]","S"][Subscript[StringJoin["-",VbChargesString],"k"]]],
(*Heading Standard*)StringJoin["\\oplus_k O_S[-",VbChargesString,"_k]"]},
(*InList*)EulerBundles11,(*Variety*)"S",(*Fancy*)FancyOutput,(*HeadingsOption*)HeadingsOption];
ShowLongExactSequences=1,ShowLongExactSequences=0
];

DualExactMonadBundleCohomology=ThirdVectorFromLongExactSequenceLabeled[
{Euler21,LabelEuler21},
{Vector1,LabelEuler11},
Superscript["\[CapitalLambda]V","*"],
3,
DimComplInters,CalabiYauRestrictions
];
ReturnCohomology=DualExactMonadBundleCohomology[[1;;DimComplInters+1]];

PrintCohomology=Text@Grid[Prepend[Transpose[{ReturnCohomology}],{Superscript["h","\[Bullet]"][Superscript[V,"*"]]}],Background->{None,{Lighter[Yellow,.9],{White,Lighter[Blend[{Blue,Green}],.8]}}},Dividers->{{Darker[Gray,.6],{Lighter[Gray,.5]},Darker[Gray,.6]},{Darker[Gray,.6],Darker[Gray,.6],{False},Darker[Gray,.6]}},Alignment->{Center},(*ItemSize\[Rule]{{10,3,5,5}},*)Frame->Darker[Gray,.6],ItemStyle->14,Spacings->{Automatic,.8}]
];
(*-----------------------------------End calculation of the exact dual monad bundle cohomology--------------------------------------------------*)


(*---------------------------------------Start calculation of the dual monad bundle cohomology--------------------------------------------------*)

If[BundleType=="CotangentBundle"||BundleType=="Lambda1CotangentBundle"||BundleType=="DualMonadBundle"||BundleType=="Lambda1DualMonadBundle",
(*Reset list of calculated line bundle cohomologie of the subvariety*)
KoszuledLineBundleList={{1}};
(*Check for correct input data*)
CheckData=CheckInputData[AmbientSpace,ComplInters,Type];
If[!CheckData[[1]],Return[CheckData[[2]]]];

If[!HodgeCalculation,(*LineBundleCounter={0,0};*)Index=1 (*Index is an index for the "ununiqueness constants" in the cohomology vector*)];
DimAmbientSpace=Length[AmbientSpace[[1]]]-Length[AmbientSpace[[3,1]]];
DimComplInters=DimAmbientSpace-Length[ComplInters];
r=Length[AmbientSpace[[3,1]]];

If[ShowKoszul,ShowLongExactSequences=1,ShowLongExactSequences=0];
EulerBundles11=-VectorBundleCharges;
EulerBundles12=Array[0^#&,r];

Vector1=Sum[Koszul[AmbientSpace,ComplInters,EulerBundles11[[i]]],{i,1,Length[VectorBundleCharges]}];
Vector2=VBr*Koszul[AmbientSpace,ComplInters,EulerBundles12];


If[ShowLES,
LabelEuler11=GenerateSequenceLabelExtended[
(*Heading Fancy*){Subsuperscript["\[CirclePlus]","k=1",nV][Subscript[ "\[ScriptCapitalO]","S"][Subscript[StringJoin["-",VbChargesString],"k"]]],
(*Heading Standard*)StringJoin["\\oplus_k O_S[-",VbChargesString,"_k]"]},
(*InList*)EulerBundles11,(*Variety*)"S",(*Fancy*)FancyOutput,(*HeadingsOption*)HeadingsOption];
LabelEuler12=GenerateSequenceLabelExtended[
(*Heading Fancy*){Subsuperscript["\[ScriptCapitalO]","S",""\[CirclePlus]rV],
(*Heading Standard*)StringJoin["O_S^(\\oplus ",ToString[rV],"r)"]},
(*InList*){},(*Variety*)"S",(*Fancy*)FancyOutput,(*HeadingsOption*)HeadingsOption];
LabelEuler13=GenerateSequenceLabelExtended[
(*Heading Fancy*){Subsuperscript["\[ScriptCapitalE]","S","\[Star]"],
(*Heading Standard*)"E^*_S"},
(*InList*){},(*Variety*)"S",(*Fancy*)FancyOutput,(*HeadingsOption*)HeadingsOption];
ShowLongExactSequences=1,ShowLongExactSequences=0
];

AuxiliaryBundle=ThirdVectorFromLongExactSequenceLabeled[
{Vector1,LabelEuler11},
{Vector2,LabelEuler12},
LabelEuler13,
1,DimComplInters,{}];

(*For a Calabi-Yau, the following constraints hold*)
If[(Type=="Calabi-Yau"||Type=="Stable")&&DimComplInters>=2,CalabiYauRestrictions={{1,0},{DimComplInters+1,0}},CalabiYauRestrictions={}];

(*Sum over this line bundlelist in the the euler sequence*)
Euler21Array=-VectorBundleConstraints;

If[ShowKoszul,ShowLongExactSequences=1,ShowLongExactSequences=0];

(*Generate zero vector first in order to avoid errors calculating ambienbt space cohomology*)
Euler21=Array[0&,DimAmbientSpace+1];
Euler21=Euler21+Sum[Koszul[AmbientSpace,ComplInters,Euler21Array[[i]]],{i,1,Length[Euler21Array]}];

If[ShowLES,
LabelEuler21=GenerateSequenceLabelExtended[
(*Heading Fancy*){Subsuperscript["\[CirclePlus]","i=1",lV][Subscript[ "\[ScriptCapitalO]","S"][Subscript[StringJoin["-",VbConstrString],"i"]]],
(*Heading Standard*)StringJoin["\\oplus_i O_S[-",VbConstrString,"_i]"]},
(*InList*)Euler21Array,(*Variety*)"S",(*Fancy*)FancyOutput,(*HeadingsOption*)HeadingsOption];
LabelEuler23=GenerateSequenceLabelExtended[
(*Heading Fancy*){Subscript["\[CapitalOmega]","S"],
(*Heading Standard*)"Omega_S"},
(*InList*){},(*Variety*)"S",(*Fancy*)FancyOutput,(*HeadingsOption*)HeadingsOption];
ShowLongExactSequences=1,ShowLongExactSequences=0
];


CotangentBundelCohomology=ThirdVectorFromLongExactSequenceLabeled[
{Euler21,LabelEuler21},
{AuxiliaryBundle,LabelEuler13},
LabelEuler23,
3,
DimComplInters,CalabiYauRestrictions
];
ReturnCohomology=CotangentBundelCohomology[[1;;DimComplInters+1]];

PrintCohomology=Text@Grid[Prepend[Transpose[{ReturnCohomology}],{Superscript["h","\[Bullet]"][Superscript[V,"*"]]}],Background->{None,{Lighter[Yellow,.9],{White,Lighter[Blend[{Blue,Green}],.8]}}},Dividers->{{Darker[Gray,.6],{Lighter[Gray,.5]},Darker[Gray,.6]},{Darker[Gray,.6],Darker[Gray,.6],{False},Darker[Gray,.6]}},Alignment->{Center},(*ItemSize\[Rule]{{10,3,5,5}},*)Frame->Darker[Gray,.6],ItemStyle->14,Spacings->{Automatic,.8}]
];
(*-----------------------------------End calculation of the dual monad bundle cohomology--------------------------------------------------*)


(*----------------------------Start calculation of Lambda^2 of the dual monad bundle cohomology---------------------------------------------*)

If[BundleType=="Lambda2CotangentBundle"||BundleType=="Lambda2DualMonadBundle",

KoszuledLineBundleList={{1}};

(*Check for correct input data*)
CheckData=CheckInputData[AmbientSpace,ComplInters,Type];
If[!CheckData[[1]],Return[CheckData[[2]]]];

(*Index is an index for the "ununiqueness constants" in the cohomology vector*)
If[!HodgeCalculation,(*LineBundleCounter={0,0};*)Index=1];
DimAmbientSpace=Length[AmbientSpace[[1]]]-Length[AmbientSpace[[3,1]]];
DimComplInters=Length[AmbientSpace[[1]]]-Length[AmbientSpace[[3,1]]]-Length[ComplInters];
r=Length[AmbientSpace[[3,1]]];
DimAmbientSpace=Length[AmbientSpace[[1]]]-r;

EulerBundles11=-VectorBundleCharges;
EulerBundles12=Array[0^#&,r];

If[ShowKoszul,ShowLongExactSequences=1,ShowLongExactSequences=0];
Vector1=Sum[Koszul[AmbientSpace,ComplInters,EulerBundles11[[i]]],{i,1,Length[VectorBundleCharges]}];
Vector2=VBr*Koszul[AmbientSpace,ComplInters,EulerBundles12];

If[ShowLES,
Euler11Label=GenerateSequenceLabelExtended[
(*Heading Fancy*){Subsuperscript["\[CirclePlus]","k=1",nV][Subscript[ "\[ScriptCapitalO]","S"][Subscript[StringJoin["-",VbChargesString],"k"]]],
(*Heading Standard*)StringJoin["\\oplus_k O_S[-",VbChargesString,"_k]"]},
(*InList*)EulerBundles11,(*Variety*)"S",(*Fancy*)FancyOutput,(*HeadingsOption*)HeadingsOption];
Euler12Label=GenerateSequenceLabelExtended[
(*Heading Fancy*){Subsuperscript["\[ScriptCapitalO]","S",""\[CirclePlus]rV],
(*Heading Standard*)StringJoin["O_S^(\\oplus ",ToString[rV],")"]},
(*InList*){},(*Variety*)"S",(*Fancy*)FancyOutput,(*HeadingsOption*)HeadingsOption];
Euler13Label=GenerateSequenceLabelExtended[
(*Heading Fancy*){Subsuperscript["\[ScriptCapitalE]","S","\[Star]"],
(*Heading Standard*)"E^*_S"},
(*InList*){},(*Variety*)"S",(*Fancy*)FancyOutput,(*HeadingsOption*)HeadingsOption];
ShowLongExactSequences=1,ShowLongExactSequences=0
];

AuxiliaryBundle=ThirdVectorFromLongExactSequenceLabeled[
{Vector1,Euler11Label},
{Vector2,Euler12Label},
Euler13Label,
1,DimComplInters,{}];
ShowLongExactSequences=0;

ODiDjSubsets=Subsets[Join[VectorBundleCharges,VectorBundleCharges],{2}];
ODiDjArray=Map[-#[[1]]-#[[2]]&,ODiDjSubsets];

If[ShowKoszul,ShowLongExactSequences=1,ShowLongExactSequences=0];
ODiDj=Sum[Sum[Koszul[AmbientSpace,ComplInters,-VectorBundleCharges[[i]]-VectorBundleCharges[[j]]],{i,j-1}],{j,Length[VectorBundleCharges]}];
Vector2=Binomial[r,2]*Koszul[AmbientSpace,ComplInters,Array[0^#&,r]];



If[ShowLES,

ODiDjLabel=GenerateSequenceLabelExtended[
(*Heading Fancy*){Subsuperscript["\[CirclePlus]","i<j",nV][Subscript[ "\[ScriptCapitalO]","S"][-Subscript[VbChargesString,"i"]-Subscript[VbChargesString,"j"]]],
(*Heading Standard*)StringJoin["\\oplus_{i<j} O_S(-",VbChargesString,"_i-",VbChargesString,"_j)"]},
(*InList*)ODiDjArray,(*Variety*)"S",(*Fancy*)FancyOutput,(*HeadingsOption*)HeadingsOption];

Vector2Label=GenerateSequenceLabelExtended[
(*Heading Fancy*){Subsuperscript["\[ScriptCapitalO]","S","\[CirclePlus]"MatrixForm[{{rV},{2}}]],
(*Heading Standard*)StringJoin["O_S^\\oplus(",ToString[rV]," over 2)"]},
(*InList*){},(*Variety*)"S",(*Fancy*)FancyOutput,(*HeadingsOption*)HeadingsOption];
AuxiliaryBundleQ1Label=GenerateSequenceLabelExtended[
(*Heading Fancy*){Subscript["\[ScriptCapitalQ]","1"],
(*Heading Standard*)"Q_1"},
(*InList*){},(*Variety*)"S",(*Fancy*)FancyOutput,(*HeadingsOption*)HeadingsOption];
ShowLongExactSequences=1,ShowLongExactSequences=0;
];

AuxiliaryBundleQ1=ThirdVectorFromLongExactSequenceLabeled[
{ODiDj,ODiDjLabel},
{Vector2,Vector2Label},
AuxiliaryBundleQ1Label,
1,DimComplInters,{}
];


If[ShowLES,
AuxiliaryBundleQ1Label=GenerateSequenceLabelExtended[
(*Heading Fancy*){Subscript["\[ScriptCapitalQ]","1"],
(*Heading Standard*)"Q_1"},
(*InList*){},(*Variety*)"S",(*Fancy*)FancyOutput,(*HeadingsOption*)0];
Vector2Label=GenerateSequenceLabelExtended[
(*Heading Fancy*){Superscript[Subsuperscript["\[ScriptCapitalE]","S","*"],""\[CirclePlus]rV],
(*Heading Standard*)StringJoin["(E_S^* )^\\oplus(",ToString[rV],")"]},
(*InList*){},(*Variety*)"S",(*Fancy*)FancyOutput,(*HeadingsOption*)0];
Lambda2AuxiliaryBundleLabel=GenerateSequenceLabelExtended[
(*Heading Fancy*){Superscript["\[CapitalLambda]",2][Subsuperscript["\[ScriptCapitalE]","S","*"]],
(*Heading Standard*)"Lambda^2(E_S^* )"},
(*InList*){},(*Variety*)"S",(*Fancy*)FancyOutput,(*HeadingsOption*)0];

ShowLongExactSequences=1,ShowLongExactSequences=0
];
Lambda2AuxiliaryBundle=ThirdVectorFromLongExactSequenceLabeled[
{AuxiliaryBundleQ1,AuxiliaryBundleQ1Label},
{VBr*AuxiliaryBundle,Vector2Label},
Lambda2AuxiliaryBundleLabel,
1,DimComplInters,{}];

If[ShowKoszul,ShowLongExactSequences=1,ShowLongExactSequences=0];


If[VectorBundleConstraints!={},
OSmSimDkSubsets=Tuples[{VectorBundleConstraints,VectorBundleCharges}];
OSmSimDkArray=Map[-#[[1]]-#[[2]]&,OSmSimDkSubsets];
,
(*else*)OSmSimDkArray=-VectorBundleCharges;
];


(*
OSmSimDk=OSmSimDk+Sum[Sum[Koszul[AmbientSpace,ComplInters,-VectorBundleConstraints[[i]]-VectorBundleCharges[[j]]],{i,Length[VectorBundleConstraints]}],{j,Length[VectorBundleCharges]}];*)
OSmSimDk=Sum[Koszul[AmbientSpace,ComplInters,OSmSimDkArray[[i]]],{i,Length[OSmSimDkArray]}];

(*Generate zero vector first in order to avoid errors calculating ambienbt space cohomology*)
Vector2=Array[0&,DimAmbientSpace+1];
Vector2=Vector2+VBr*Sum[Koszul[AmbientSpace,ComplInters,-VectorBundleConstraints[[i]]],{i,Length[VectorBundleConstraints]}];

If[ShowLES,
(*OSmSimDkSubsets=Subsets[Join[VectorBundleConstraints,VectorBundleCharges],{2}];
OSmSimDkArray=Map[-#[[1]]-#[[2]]&,OSmSimDkSubsets];
*)
Vector2Array=Flatten[Array[-VectorBundleConstraints&,r],1];

OSmSimDkLabel=GenerateSequenceLabelExtended[
(*Heading Fancy*){Subsuperscript["\[CirclePlus]","i=1",lV]Subsuperscript["\[CirclePlus]","k=1",nV]Subscript[ "\[ScriptCapitalO]","S"][-Subscript[VbConstrString,"j"]-Subscript[VbChargesString,"k"]],
(*Heading Standard*)StringJoin["\\oplus_i\\oplus_k O_S(-",VbConstrString,"_j-",VbChargesString,"_k)"]},
(*InList*)OSmSimDkArray,(*Variety*)"S",(*Fancy*)FancyOutput,(*HeadingsOption*)HeadingsOption];
Vector2Label=GenerateSequenceLabelExtended[
(*Heading Fancy*){Subsuperscript["\[CirclePlus]","i=1",lV]Superscript[(Subscript[ "\[ScriptCapitalO]","S"][-Subscript[VbConstrString,"j"]]),"\[CirclePlus]r"],
(*Heading Standard*)""},
(*InList*)Vector2Array,(*Variety*)"S",(*Fancy*)FancyOutput,(*HeadingsOption*)HeadingsOption];
TensorProductAuxiliaryBundleLabel=GenerateSequenceLabelExtended[
(*Heading Fancy*){"\[ScriptCapitalE]"\[CircleTimes]Subsuperscript["\[CirclePlus]","i=1",lV]Subscript[ "\[ScriptCapitalO]","S"][-Subscript[VbConstrString,"i"]],
(*Heading Standard*)StringJoin["E\\otimes \\oplus_i O_S(-",VbConstrString,"_i)"]},
(*InList*){},(*Variety*)"S",(*Fancy*)FancyOutput,(*HeadingsOption*)HeadingsOption];
ShowLongExactSequences=1,ShowLongExactSequences=0;
];

TensorProductAuxiliaryBundle=ThirdVectorFromLongExactSequenceLabeled[
{OSmSimDk,OSmSimDkLabel},
{Vector2,Vector2Label},
TensorProductAuxiliaryBundleLabel,
1,5,{}];

(*Taking Calabi-Yau constraints on the Hodge diamond into account*)
If[(Type=="Calabi-Yau"||Type=="Stable")&&DimComplInters>=3,CalabiYauRestrictions={{1,0},{DimComplInters+1,0}},CalabiYauRestrictions={}];

If[ShowKoszul,ShowLongExactSequences=1,ShowLongExactSequences=0];
OSmSimSj=Array[0^#&,DimAmbientSpace+1];
OSmSimSjArray={};
For[i=1,i<= Length[VectorBundleConstraints],i++,
For[j=1,j<= Length[VectorBundleConstraints],j++,
OSmSimSj=OSmSimSj+Koszul[AmbientSpace,ComplInters,-VectorBundleConstraints[[i]]-VectorBundleConstraints[[j]]];
AppendTo[OSmSimSjArray,-VectorBundleConstraints[[i]]-VectorBundleConstraints[[j]]];
];
];
If[ShowLES,
OSmSimSjLabel=GenerateSequenceLabelExtended[
(*Heading Fancy*){Subsuperscript["\[CirclePlus]","i=1",lV]Subsuperscript["\[CirclePlus]","j=1",lV][Subscript[ "\[ScriptCapitalO]",VbConstrString][-Subscript[VbConstrString,"i"]-Subscript[VbConstrString,"j"]]],
(*Heading Standard*)StringJoin["\\oplus_{i,j} O_S(-",VbConstrString,"_i-",VbConstrString,"_j)"]},
(*InList*)OSmSimSjArray,(*Variety*)"S",(*Fancy*)FancyOutput,(*HeadingsOption*)HeadingsOption];
TensorProductOmega1Label=GenerateSequenceLabelExtended[
(*Heading Fancy*){Subscript["\[CapitalOmega]",1]\[CircleTimes]Subsuperscript["\[CirclePlus]","i=1",lV]Subscript[ "\[ScriptCapitalO]","S"][-Subscript[VbConstrString,"i"]],
(*Heading Standard*)StringJoin["Omega_1\\otimes\\oplus_i O_S(-",VbConstrString,"_i)"]},
(*InList*){},(*Variety*)"S",(*Fancy*)FancyOutput,(*HeadingsOption*)HeadingsOption];
ShowLongExactSequences=1,ShowLongExactSequences=0;
];

TensorProductOmega1=ThirdVectorFromLongExactSequenceLabeled[
{OSmSimSj,OSmSimSjLabel},
{TensorProductAuxiliaryBundle,TensorProductAuxiliaryBundleLabel},
TensorProductOmega1Label,
3,5,{}];


If[ShowKoszul,ShowLongExactSequences=1,ShowLongExactSequences=0];
OSmSimSj2=Array[0^#&,DimAmbientSpace+1];
OSmSimSj2Array={};
For[i=1,i<= Length[VectorBundleConstraints],i++,
For[j=1,j< i,j++,
OSmSimSj2=OSmSimSj2+Koszul[AmbientSpace,ComplInters,-VectorBundleConstraints[[i]]-VectorBundleConstraints[[j]]];
AppendTo[OSmSimSj2Array,-VectorBundleConstraints[[i]]-VectorBundleConstraints[[j]]];
];
];

If[ShowLES,
OSmSimSj2Label=GenerateSequenceLabelExtended[
(*Heading Fancy*){Style[Subscript["\[CirclePlus]","i<j"]Subscript[ "\[ScriptCapitalO]","S"][-Subscript[VbConstrString,"i"]-Subscript[VbConstrString,"j"]]],
(*Heading Standard*)StringJoin["\\oplus_{i<j} O_S(-",VbConstrString,"_i-",VbConstrString,"_j)"]},
(*InList*)OSmSimSj2Array,(*Variety*)"S",(*Fancy*)FancyOutput,(*HeadingsOption*)HeadingsOption];
AuxBundleQ2Label=GenerateSequenceLabelExtended[
(*Heading Fancy*){Subscript["\[ScriptCapitalQ]",2],
(*Heading Standard*)"Q_2"},
(*InList*){},(*Variety*)"S",(*Fancy*)FancyOutput,(*HeadingsOption*)HeadingsOption];
ShowLongExactSequences=1,ShowLongExactSequences=0
];

AuxBundleQ2=ThirdVectorFromLongExactSequenceLabeled[
{OSmSimSj2,OSmSimSj2Label},
{TensorProductOmega1,TensorProductOmega1Label},
AuxBundleQ2Label,
2,DimComplInters,{}];

If[ShowLES,
AuxBundleQ2Label=GenerateSequenceLabelExtended[
(*Heading Fancy*){Subscript["\[ScriptCapitalQ]",2],
(*Heading Standard*)"Q_2"},
(*InList*){},(*Variety*)"S",(*Fancy*)FancyOutput,(*HeadingsOption*)0];
Lambda2OmegaLabel=GenerateSequenceLabelExtended[
(*Heading Fancy*){Superscript["\[CapitalLambda]",2][Subscript["\[CapitalOmega]","S"]],
(*Heading Standard*)"Lambda^2(Omega_1)"},
(*InList*){},(*Variety*)"S",(*Fancy*)FancyOutput,(*HeadingsOption*)0];
];

Lambda2Omega=ThirdVectorFromLongExactSequenceLabeled[
{AuxBundleQ2,AuxBundleQ2Label},
{Lambda2AuxiliaryBundle,Lambda2AuxiliaryBundleLabel},
Lambda2OmegaLabel,
3,DimComplInters,CalabiYauRestrictions];

ReturnCohomology=Lambda2Omega[[1;;DimComplInters+1]];
PrintCohomology=Text@Grid[Prepend[Transpose[{ReturnCohomology}],{Superscript["h","\[Bullet]"][Superscript["\[CapitalLambda]",2][ Superscript[V,"*"] ]]}],Background->{None,{Lighter[Yellow,.9],{White,Lighter[Blend[{Blue,Green}],.8]}}},Dividers->{{Darker[Gray,.6],{Lighter[Gray,.5]},Darker[Gray,.6]},{Darker[Gray,.6],Darker[Gray,.6],{False},Darker[Gray,.6]}},Alignment->{Center},(*ItemSize\[Rule]{{10,3,5,5}},*)Frame->Darker[Gray,.6],ItemStyle->14,Spacings->{Automatic,.8}]

];
(*----------------------------End calculation of Lambda^2 of the dual monad bundle cohomology---------------------------------------------*)


(*------------------------------------Start calculation of the tangent bundle cohomology----------------------------------------------*)
If[BundleType=="TangentBundle"||BundleType=="MonadBundle",
KoszuledLineBundleList={{1}};

(*Check for correct input data*)
CheckData=CheckInputData[AmbientSpace,ComplInters,Type];
If[!CheckData[[1]],Return[CheckData[[2]]]];

DimAmbientSpace=Length[AmbientSpace[[1]]]-Length[AmbientSpace[[3,1]]];
DimComplInters=Length[AmbientSpace[[1]]]-Length[AmbientSpace[[3,1]]]-Length[ComplInters];
Index=1; (*Index is an index for the "ununiqueness constants" in the cohomology vector*)


If[ShowKoszul,ShowLongExactSequences=1,ShowLongExactSequences=0];
Vector1=VBr*Koszul[AmbientSpace,ComplInters,Array[0^#&,r]];
Vector2=Sum[Koszul[AmbientSpace,ComplInters,VectorBundleCharges[[i]]],{i,1,Length[VectorBundleCharges]}];



EulerBundles11=VectorBundleCharges;
EulerBundles12=Array[0^#&,r];

If[ShowLES,
LabelEuler11=GenerateSequenceLabelExtended[
(*Heading Fancy*){Subsuperscript["\[CirclePlus]","k=1",nV][Subscript[ "\[ScriptCapitalO]","S"][Subscript[VbChargesString,"k"]]],
(*Heading Standard*)"\\oplus_k O_S[D_k]"},
(*InList*)EulerBundles11,(*Variety*)"S",(*Fancy*)FancyOutput,(*HeadingsOption*)HeadingsOption];
LabelEuler12=GenerateSequenceLabelExtended[
(*Heading Fancy*){Subsuperscript["\[ScriptCapitalO]","S","\[CirclePlus]"rV],
(*Heading Standard*)"O_S^(\\oplus r)"},
(*InList*){},(*Variety*)"S",(*Fancy*)FancyOutput,(*HeadingsOption*)HeadingsOption];
LabelEuler13=GenerateSequenceLabelExtended[
(*Heading Fancy*){Subscript["\[ScriptCapitalE]","S"],
(*Heading Standard*)"E_S"},
(*InList*){},(*Variety*)"S",(*Fancy*)FancyOutput,(*HeadingsOption*)HeadingsOption];
ShowLongExactSequences=1,ShowLongExactSequences=0
];


AuxiliaryBundle=ThirdVectorFromLongExactSequenceLabeled[
{Vector1,LabelEuler12},
{Vector2,LabelEuler11},
LabelEuler13,
3,DimComplInters,{}];

(*Taking Calabi-Yau constraints on the Hodge diamond into account*)
If[(Type=="Calabi-Yau"||Type=="Stable")&&DimComplInters>=2,CalabiYauRestrictions={{1,0},{DimComplInters+1,0}},CalabiYauRestrictions={}];

If[ShowKoszul,ShowLongExactSequences=1,ShowLongExactSequences=0];
Vector2=Array[0&,DimAmbientSpace+1];
Vector2=Vector2+Sum[Koszul[AmbientSpace,ComplInters,VectorBundleConstraints[[i]]],{i,1,Length[VectorBundleConstraints]}];
(*arbeitarbeit*)

(*Sum over this line bundlelist in the the euler sequence*)
Euler21Array=VectorBundleConstraints;

If[ShowLES,
LabelEuler21=GenerateSequenceLabelExtended[
(*Heading Fancy*){Subsuperscript["\[CirclePlus]","i=1","l"][Subscript[ "\[ScriptCapitalO]","S"][Subscript["S","i"]]],
(*Heading Standard*)"\\oplus_i O_S[S_i]"},
(*InList*)Euler21Array,(*Variety*)"S",(*Fancy*)FancyOutput,(*HeadingsOption*)HeadingsOption];
LabelEuler23=GenerateSequenceLabelExtended[
(*Heading Fancy*){V,
(*Heading Standard*)StringJoin[ToString[V],"_S"]},
(*InList*){},(*Variety*)"S",(*Fancy*)FancyOutput,(*HeadingsOption*)HeadingsOption];
ShowLongExactSequences=1,ShowLongExactSequences=0
];


TangentBundelCohomology=ThirdVectorFromLongExactSequenceLabeled[
{AuxiliaryBundle,LabelEuler13},
{Vector2,LabelEuler21},
LabelEuler23,
1,
DimComplInters,CalabiYauRestrictions
];
ReturnCohomology=TangentBundelCohomology[[1;;DimComplInters+1]];
PrintCohomology=Text@Grid[Prepend[Transpose[{ReturnCohomology}],{Superscript["h","\[Bullet]"][ V ]}],Background->{None,{Lighter[Yellow,.9],{White,Lighter[Blend[{Blue,Green}],.8]}}},Dividers->{{Darker[Gray,.6],{Lighter[Gray,.5]},Darker[Gray,.6]},{Darker[Gray,.6],Darker[Gray,.6],{False},Darker[Gray,.6]}},Alignment->{Center},(*ItemSize\[Rule]{{10,3,5,5}},*)Frame->Darker[Gray,.6],ItemStyle->14,Spacings->{Automatic,.8}]
];
(*------------------------------------End calculation of the tangent bundle cohomology----------------------------------------------*)

(*-----------------Start calculation of the full Hodge diamond using Lambda^0 Lambda^1 and Lambda^2----------------------*)
If[BundleType=="HodgeDiamond",

(*EarlyTime=DateList[];*)
KoszuledLineBundleList={{1}};

(*Check for correct input data*)
CheckData=CheckInputData[AmbientSpace,ComplInters,Type];
If[!CheckData[[1]],Return[CheckData[[2]]]];

DimAmbientSpace=Length[AmbientSpace[[1]]]-Length[AmbientSpace[[3,1]]];
DimComplInters=Length[AmbientSpace[[1]]]-Length[AmbientSpace[[3,1]]]-Length[ComplInters];
Index=1; (*Index is an index for the "ununiqueness constants" in the cohomology vector*);
(*LineBundleCounter={0,0};*)

(*Vector of parameters which will be constraint by altering sums in the long exact sequence*)
RowZero=StartCohomologyOf[(*HodgeCalculation*)True,"Lambda0CotangentBundle",AmbientSpace,ComplInters,Type,VerboseLevel,FancyOutput,SearchForTwistedIn];
RowOne=StartCohomologyOf[(*HodgeCalculation*)True,"CotangentBundle",AmbientSpace,ComplInters,Type,VerboseLevel,FancyOutput,SearchForTwistedIn];
RowTwo=StartCohomologyOf[(*HodgeCalculation*)True,"Lambda2CotangentBundle",AmbientSpace,ComplInters,Type,VerboseLevel,FancyOutput,SearchForTwistedIn];
ParameterMatrix=Array[Subscript[B, Index+#1-1,Index+#2-1]&,{Length [RowZero],Length [RowZero]}];
WorkingMatrix=Array[Subscript[X, Index+#1-1,Index+#2-1]&,{Length [RowZero],Length [RowZero]}];
ParameterMatrix[[1]]=RowZero;
ParameterMatrix[[2]]=RowOne;
ParameterMatrix[[3]]=RowTwo;
WorkingVector=Flatten[WorkingMatrix];

(*In case that only the line bundkes are collected, nothing more has to be done here*)
If[LineBundleCollector[[1]],Return[]];
(*Solutions of the equations, given by exact sequences between zeros in the long exact sequence*)
(*Solution=Solve[WorkingVector - ParameterVector\[Equal]0&& EquationsToSolve\[Equal]0,WorkingVector];*)
Solution={Reduce[WorkingVector-ParameterVector==0(*&&EquationsToSolve\[Equal]0*),WorkingVector]}/.(y__&&z__):>{y,z}/.(x_==y_):>(x->y);

If[DimComplInters==4,

Solution={Reduce[WorkingMatrix==ParameterMatrix && 
CounterTranspose[ParameterMatrix]== ParameterMatrix &&
Transpose[ParameterMatrix] == ParameterMatrix ,WorkingVector
]}/.(y__&&z__):>{y,z}/.(x_==y_):>(x->y);
,
Solution={Reduce[WorkingMatrix==ParameterMatrix && 
CounterTranspose[ParameterMatrix]== ParameterMatrix &&
Transpose[ParameterMatrix] == ParameterMatrix ,WorkingVector
]}/.(y__&&z__):>{y,z}/.(x_==y_):>(x->y);
];
(*Print[(Solution\[Equal]{}|| Solution\[Equal]{False})];*)
If[Solution=={False},Return["No Solution"]];
If[Solution=={},Return["No Solution"],
(*Print[ResultMatrix];*)
ResultMatrix=Transpose[Flatten[WorkingMatrix/.Solution,1]];
BettiVector=Array[0^#&,2*Length[ResultMatrix]-1];
For[j=1,j<=Length[ResultMatrix],j++,
For[i=1,i<=Length[ResultMatrix[[j]]],i++,
BettiVector[[j+i-1]]=BettiVector[[j+i-1]]+ResultMatrix[[j,i]]
];
];


If[FancyOutput==1,
ReturnCohomology={MatrixForm[ResultMatrix],MatrixForm[BettiVector]};
PrintCohomology=TableForm[{
(*Hodge Diamond*)
Rotate[
Grid[
Table[
Rotate[ResultMatrix[[i,j]],45\[Degree]]
,{i,1,Length [RowZero]},{j,1,Length [RowZero]}]
,Background->{Automatic,Automatic,Flatten[Table[{i, j} -> If[EvenQ[Plus @@ Floor[{i - 1, j - 1}]],Lighter[Blend[{Blue,Green}],.8], White], {i, DimComplInters+1}, {j, DimComplInters+1}]]},
Dividers->{
{Darker[Gray,.6],{Lighter[Gray,.5]},Darker[Gray,.6]},
{Darker[Gray,.6],{Lighter[Gray,.5]},Darker[Gray,.6]}},
Alignment->{Center},(*ItemSize\[Rule]{{10,3,5,5}},*)
Frame->Darker[Gray,.6],ItemStyle->14,Spacings->{Automatic,.8}],-45\[Degree]],
(*Betti Numbers*)
Text@Grid[Transpose[{BettiVector}],
Background->{None,{Lighter[Blend[{Blue,Green}],.8],{White,Lighter[Blend[{Blue,Green}],.8]}}},Dividers->{{Darker[Gray,.6],{Lighter[Gray,.5]},Darker[Gray,.6]},{Darker[Gray,.6],Lighter[Gray,.5],{Lighter[Gray,.5]},Darker[Gray,.6]}},Alignment->{Center},(*ItemSize\[Rule]{{10,3,5,5}},*)Frame->Darker[Gray,.6],ItemStyle->14,Spacings->{Automatic,.8}],
(*Euler character*)
(*Graphics[{*)
(*{Lighter[Blend[{Blue,Green}],.8],{EdgeForm[Thick],Lighter[Blend[{Blue,Green}],.8],Disk[{0,0},100]}
},*)
Text@Grid[{{Style[StringJoin["\[Chi] = ",ToString[Sum[(-1)^(k-1)*BettiVector[[k]],{k,1,Length[BettiVector]}]]] ,FontSize->15]}},Background->Lighter[Blend[{Blue,Green}],.8],Frame->Darker[Gray,.6]]
(*}]*)
},TableDirections->Row];
,
(*else standard output*)
ReturnCohomology={MatrixForm[ResultMatrix],MatrixForm[BettiVector]};
];
];
];
(*-----------------------End calculation of  the full Hodge diamond using Lambda^0 Lambda^1 and Lambda^2----------------------*)


(*------------------------------------------Start calculation of EndV Cohomology ---------------------------------------------*)


If[BundleType=="EndTangentBundle"||BundleType=="EndMonadBundle",

KoszuledLineBundleList={{1}};

(*Check for correct input data*)
CheckData=CheckInputData[AmbientSpace,ComplInters,Type];
If[!CheckData[[1]],Return[CheckData[[2]]]];

Index=1;

DimAmbientSpace=Length[AmbientSpace[[1]]]-Length[AmbientSpace[[3,1]]];
DimComplInters=DimAmbientSpace-Length[ComplInters];
r=Length[AmbientSpace[[3,1]]];


(* a)  Epsilon otimes O_S(-Mi)*)
(*        E        x     OSmMi *)
If[ShowKoszul,ShowLongExactSequences=1,ShowLongExactSequences=0];

If[VectorBundleConstraints!= {},
OSmMi=VBr*Sum[Koszul[AmbientSpace,ComplInters,-VectorBundleConstraints[[i]]],{i,1,Length[VectorBundleConstraints]}],
(*else*)
OSmMi=Koszul[AmbientSpace,ComplInters,Array[0&,Length[AmbientSpace[[3,1]]]]]
];


If[VectorBundleConstraints!={},
OSNrmMi=Sum[Sum[Koszul[AmbientSpace,ComplInters,VectorBundleCharges[[i]]-VectorBundleConstraints[[j]]],{i,1,Length[VectorBundleCharges]}],{j,1,Length[VectorBundleConstraints]}],
(*else*)OSNrmMi=Sum[Koszul[AmbientSpace,ComplInters,VectorBundleCharges[[i]]],{i,1,Length[VectorBundleCharges]}]
];
(*Print[Array[VectorBundleCharges[[i]]-VectorBundleConstraints[[j]],{i,1,Length[VectorBundleCharges]},{j,1,Length[VectorBundleConstraints]}]];*)

If[ShowLES||ShowSpecialLES,
OSNrmMiArray={};
If[VectorBundleConstraints!={},
For[i=1,i<=Length[VectorBundleConstraints],i++,
For[j=1,j<=Length[VectorBundleCharges],j++,
AppendTo[OSNrmMiArray,VectorBundleCharges[[j]]-VectorBundleConstraints[[i]]];
];
],
(*else*)
OSNrmMiArray=VectorBundleCharges;
];
OSmMiLabel=GenerateSequenceLabelExtended[
(*Heading Fancy*){Subsuperscript["\[CirclePlus]","i=1",lV]Superscript[Subscript["\[ScriptCapitalO]","S"][-Subscript[VbConstrString,"i"]],""\[CirclePlus]rV],
(*Heading Standard*)""},
(*InList*)-VectorBundleConstraints,(*Variety*)"S",(*Fancy*)FancyOutput,(*HeadingsOption*)HeadingsOption];
OSNrmMiLabel=GenerateSequenceLabelExtended[
(*Heading Fancy*){Subsuperscript["\[CirclePlus]","\[Rho]=1",nV]Subsuperscript["\[CirclePlus]","i=1",lV]Subscript["\[ScriptCapitalO]","S"][Subscript[VbChargesString,"\[Rho]"]-Subscript[VbConstrString,"i"]],
(*Heading Standard*)""},
(*InList*)OSNrmMiArray,(*Variety*)"S",(*Fancy*)FancyOutput,(*HeadingsOption*)HeadingsOption];
ExOSmMiLabel=GenerateSequenceLabelExtended[
(*Heading Fancy*){Subsuperscript["\[CirclePlus]","i=1",lV]"\[ScriptCapitalE]\[CircleTimes]"Subscript["\[ScriptCapitalO]","S"][-Subscript[VbConstrString,"i"]],
(*Heading Standard*)""},
(*InList*){},(*Variety*)"S",(*Fancy*)FancyOutput,(*HeadingsOption*)HeadingsOption];
ShowLongExactSequences=1,ShowLongExactSequences=0
];
(*Print[ExOSmMiPart1Label];*)

If[SpecialEndBundle,
SpecialConstraint={{3,0}},
SpecialConstraint={};
];
ExOSmMi=ThirdVectorFromLongExactSequenceLabeled[
(* r*oplus O_S(-S_i)*)
{OSmMi,OSmMiLabel},
(* oplus O_S(D_rho-S_i)*)
{OSNrmMi,OSNrmMiLabel},
ExOSmMiLabel,
3,DimComplInters,SpecialConstraint];(*Constraint valid, if f injective*)
(*Print["E x O_S(-Si) = ",ExOSmMi[[1;;DimComplInters+1]]];*)



(*
(*Test the dual*)
EdualxOSS=ThirdVectorFromLongExactSequence[
(* oplus O_S(D_rho-S_i)*)
Sum[Sum[Koszul[AmbientSpace,ComplInters,-VectorBundleCharges[[i]]+VectorBundleConstraints[[j]]],{i,1,Length[VectorBundleCharges]}],{j,1,Length[VectorBundleConstraints]}],
(* r*oplus O_S(-S_i)*)
VBr*Sum[Koszul[AmbientSpace,ComplInters,VectorBundleConstraints[[i]]],{i,1,Length[VectorBundleConstraints]}],
1,DimComplInters,{}];
(*Print["E x O_S(-Si) = ",EdualxOSS[[1;;DimComplInters+1]]];*)
*)

(* b)  r*O_S otimes Epsilon* *)
(*       rOS    x     Edual  *)

If[ShowKoszul,ShowLongExactSequences=1,ShowLongExactSequences=0];
(*oplus O_S(-D_rho)*)
OSmNr=VBr*Sum[Koszul[AmbientSpace,ComplInters,-VectorBundleCharges[[i]]],{i,1,Length[VectorBundleCharges]}];
(*r*O_S*)
Vector2=VBr^2*Koszul[AmbientSpace,ComplInters,Array[0^#&,r]];


If[ShowLES,
OSmNrLabel=GenerateSequenceLabelExtended[
(*Heading Fancy*){Subsuperscript["\[CirclePlus]","\[Rho]=1",nV]Superscript[Subscript["\[ScriptCapitalO]","S"][-Subscript[VbChargesString, "\[Rho]"]],""\[CirclePlus]rV],
(*Heading Standard*)StringJoin["\\oplus_r O_S(-",VbChargesString,"_r)"]},
(*InList*)-VectorBundleCharges,(*Variety*)"S",(*Fancy*)FancyOutput,(*HeadingsOption*)HeadingsOption];
Vector2Label=GenerateSequenceLabelExtended[
(*Heading Fancy*){Subsuperscript["\[ScriptCapitalO]","S",""\[CirclePlus]rV^2],
(*Heading Standard*)StringJoin["O_S\\oplus r_V^2"]},
(*InList*){},(*Variety*)"S",(*Fancy*)FancyOutput,(*HeadingsOption*)HeadingsOption];
rOSxEdualLabel=GenerateSequenceLabelExtended[
(*Heading Fancy*){Subsuperscript["\[ScriptCapitalO]","S",""\[CirclePlus]rV]Superscript["\[CircleTimes] \[ScriptCapitalE]","*"],
(*Heading Standard*)"O_S x E*"},
(*InList*){},(*Variety*)"S",(*Fancy*)FancyOutput,(*HeadingsOption*)HeadingsOption];
ShowLongExactSequences=1,ShowLongExactSequences=0
];


rOSxEdual=ThirdVectorFromLongExactSequenceLabeled[
{OSmNr,OSmNrLabel},
{Vector2,Vector2Label},
rOSxEdualLabel,
1,DimComplInters,{}];
(*Print["rO_S x E* = ",rOSxEdual[[1;;DimComplInters+1]]];*)


(* c)  oplus O_S(D_rho) otimes Epsilon* *) 
(*          OSDr           x     Edual  *)


If[ShowKoszul,ShowLongExactSequences=1,ShowLongExactSequences=0];
OSNrmNr=Sum[Sum[Koszul[AmbientSpace,ComplInters,VectorBundleCharges[[i]]-VectorBundleCharges[[j]]],{i,Length[VectorBundleCharges]}],{j,Length[VectorBundleCharges]}];
VBrOSNr=VBr*Sum[Koszul[AmbientSpace,ComplInters,VectorBundleCharges[[i]]],{i,1,Length[VectorBundleCharges]}];

If[ShowLES||ShowSpecialLES,
OSNrmNrArray=Flatten[Array[VectorBundleCharges[[#1]]-VectorBundleCharges[[#2]]&,{Length[VectorBundleCharges],Length[VectorBundleCharges]}],1];
VBrOSNrArray=Flatten[Array[VectorBundleCharges&,VBr],1];
OSNrmNrLabel=GenerateSequenceLabelExtended[
(*Heading Fancy*){Subsuperscript["\[CirclePlus]","\[Rho],\[Rho]'=1",nV]Subscript["\[ScriptCapitalO]","S"][Subscript[VbChargesString, "\[Rho]'"]-Subscript[VbChargesString, "\[Rho]"]],
(*Heading Standard*)StringJoin["\\oplus_r1,r2 O_S(",VbChargesString,"_r1)-",VbChargesString,"_r2)"]},
(*InList*)OSNrmNrArray,(*Variety*)"S",(*Fancy*)FancyOutput,(*HeadingsOption*)HeadingsOption];
VBrOSNrLabel=GenerateSequenceLabelExtended[
(*Heading Fancy*){Subsuperscript["\[CirclePlus]","\[Rho]'=1",nV]Superscript[Subscript["\[ScriptCapitalO]","S"][Subscript[VbChargesString, "\[Rho]'"]],""\[CirclePlus]rV],
(*Heading Standard*)StringJoin["O_S\\oplus r_V^2"]},
(*InList*)VBrOSNrArray,(*Variety*)"S",(*Fancy*)FancyOutput,(*HeadingsOption*)HeadingsOption];
OSNrxEdualLabel=GenerateSequenceLabelExtended[
(*Heading Fancy*){Subsuperscript["\[CirclePlus]","\[Rho]=1",nV][Subscript["\[ScriptCapitalO]","S"][Subscript[VbChargesString,"\[Rho]"]]]\[CircleTimes] Superscript["\[ScriptCapitalE]","*"],
(*Heading Standard*)"O_S x E*"},
(*InList*){},(*Variety*)"S",(*Fancy*)FancyOutput,(*HeadingsOption*)HeadingsOption];
ShowLongExactSequences=1,ShowLongExactSequences=0
];

OSNrxEdual=
ThirdVectorFromLongExactSequenceLabeled[
(* oplus O_S(D_i-D_j) *)
{OSNrmNr,OSNrmNrLabel},
(*oplus O_S(D_rho)*)
{VBrOSNr,VBrOSNrLabel},
OSNrxEdualLabel,
1,DimComplInters,{}];

(*
(* alternative way of computation *)
Print["O_S(Dr) x E* = ",OSDrxEdual[[1;;DimComplInters+1]]];
OSDrxEdual=
Sum[
ThirdVectorFromLongExactSequence[
(* oplus O_S(D_i-D_j) *)
Sum[Koszul[AmbientSpace,ComplInters,VectorBundleCharges[[i]]-VectorBundleCharges[[j]]],{j,Length[VectorBundleCharges]}],
(*oplus O_S(D_rho)*)
VBr*Koszul[AmbientSpace,ComplInters,VectorBundleCharges[[i]]],
1,DimComplInters,{}]
,{i,Length[VectorBundleCharges]}];
 
Print["O_S(Dr) x E* = ",OSDrxEdual[[1;;DimComplInters+1]]];
*)
(*
(*Test the dual*)
OSmDrxE=ThirdVectorFromLongExactSequence[
(*oplus O_S(D_rho)*)
VBr*Sum[Koszul[AmbientSpace,ComplInters,-VectorBundleCharges[[i]]],{i,1,Length[VectorBundleCharges]}],
(* oplus O_S(D_i-D_j) *)
Sum[Sum[Koszul[AmbientSpace,ComplInters,-VectorBundleCharges[[i]]+VectorBundleCharges[[j]]],{i,Length[VectorBundleCharges]}],{j,Length[VectorBundleCharges]}],
3,DimComplInters,{}];
(*Print["O_S(Dr) x E* = ",OSmDrxE[[1;;DimComplInters+1]]];*)
*)


(* d)  oplus O_S(S_i) otimes Epsilon* *)
(*          OSSi         x     Edual  *)

(*Actually not needed, since Serre duality*)
If[SearchForTwisted==1,
If[ShowKoszul,ShowLongExactSequences=1,ShowLongExactSequences=0];
(* oplus O_S(-N_rho+M_i)*)
If[VectorBundleConstraints!={},
OSmNrMi=Sum[Sum[Koszul[AmbientSpace,ComplInters,-VectorBundleCharges[[i]]+VectorBundleConstraints[[j]]],{i,1,Length[VectorBundleCharges]}],{j,1,Length[VectorBundleConstraints]}],
(*else*)
OSmNrMi=Sum[Koszul[AmbientSpace,ComplInters,-VectorBundleCharges[[i]]],{i,1,Length[VectorBundleCharges]}];
];

(* r*oplus O_S(M_i)*)
VBrOSMi=Array[0&,DimAmbientSpace+1];
VBrOSMi=VBrOSMi+VBr*Sum[Koszul[AmbientSpace,ComplInters,VectorBundleConstraints[[i]]],{i,1,Length[VectorBundleConstraints]}];

If[ShowLES||ShowSpecialLES,
If[VectorBundleConstraints!={},
OSNrmNrArray=Flatten[Array[VectorBundleConstraints[[#1]]-VectorBundleCharges[[#2]]&,{Length[VectorBundleConstraints],Length[VectorBundleCharges]}],1],
(*else*)OSNrmNrArray=-VectorBundleCharges;
];
VBrOSMiArray=Flatten[Array[VectorBundleConstraints&,VBr],1];

OSmNrMiLabel=GenerateSequenceLabelExtended[
(*Heading Fancy*){Subsuperscript["\[CirclePlus]","i=1",lV]Subsuperscript["\[CirclePlus]","\[Rho]=1",nV]Subscript["\[ScriptCapitalO]","S"][Subscript[VbConstrString, "i"]-Subscript[VbChargesString, "\[Rho]"]],
(*Heading Standard*)StringJoin["\\oplus_r\\oplus_i O_S(",VbChargesString,"_r)-",VbConstrString,"_i)"]},
(*InList*)OSNrmNrArray,(*Variety*)"S",(*Fancy*)FancyOutput,(*HeadingsOption*)HeadingsOption];
VBrOSMiLabel=GenerateSequenceLabelExtended[
(*Heading Fancy*){Subsuperscript["\[CirclePlus]","i=1",lV]Superscript[Subscript["\[ScriptCapitalO]","S"][Subscript[VbConstrString, "i"]],"\[CirclePlus]"rV],
(*Heading Standard*)StringJoin[""]},
(*InList*)VBrOSMiArray(*VBrOSNrArray*),(*Variety*)"S",(*Fancy*)FancyOutput,(*HeadingsOption*)HeadingsOption];

OSMixEdualLabel=GenerateSequenceLabelExtended[
(*Heading Fancy*){Subsuperscript["\[CirclePlus]","i=1",lV][Subscript["\[ScriptCapitalO]","S"][Subscript[VbConstrString,"i"]]]\[CircleTimes] Superscript["\[ScriptCapitalE]","*"],
(*Heading Standard*)"O_S x E*"},
(*InList*){},(*Variety*)"S",(*Fancy*)FancyOutput,(*HeadingsOption*)HeadingsOption];
ShowLongExactSequences=1,ShowLongExactSequences=0
];

OSMixEdual=ThirdVectorFromLongExactSequenceLabeled[
{OSmNrMi,OSmNrMiLabel},
{VBrOSMi,VBrOSMiLabel},
OSMixEdualLabel,
1,DimComplInters,{(*{2,0}*)}];

(*Print["O_S(Si) x E* = ",OSMixEdual[[1;;DimComplInters+1]]];*)
,
(*Else use Serre duality*)
(*In fact d) is a) dual *)
If[ShowLES,
OSMixEdualLabel=GenerateSequenceLabelExtended[
(*Heading Fancy*){Subsuperscript["\[CirclePlus]","i=1",lV][Subscript["\[ScriptCapitalO]","S"][Subscript[VbConstrString,"i"]]]\[CircleTimes] Superscript["\[ScriptCapitalE]","*"],
(*Heading Standard*)"O_S x E*"},
(*InList*){},(*Variety*)"S",(*Fancy*)FancyOutput,(*HeadingsOption*)HeadingsOption];
ShowLongExactSequences=1,ShowLongExactSequences=0
];

OSMixEdual=Array[ExOSmMi[[DimComplInters+2-#]]&,DimComplInters+1];
For[i=1,i<= Length[ComplInters],i++,AppendTo[OSMixEdual,0]];
(*Print["O_S(Si) x E* = ",OSMixEdual[[1;;DimComplInters+1]]];*)
];

(*delta)  oplus O_S(S_i) otimes Vdual*)
(*               ODSi      v      Vdual*)
If[ShowKoszul,ShowLongExactSequences=1,ShowLongExactSequences=0];
(*Error not yet corrected*)

OSSimSj=Array[0&,DimAmbientSpace+1];
OSSimSj=OSSimSj+Sum[Sum[Koszul[AmbientSpace,ComplInters,VectorBundleConstraints[[i]]-VectorBundleConstraints[[j]]],{i,Length[VectorBundleConstraints]}],{j,Length[VectorBundleConstraints]}];
OSSimSjArray=Flatten[Array[VectorBundleConstraints[[#1]]-VectorBundleConstraints[[#2]]&,{Length[VectorBundleConstraints],Length[VectorBundleConstraints]}],1];


(*Vector1=Length[ComplInters]^2Koszul[AmbientSpace,ComplInters,Array[0^#&,r]];*)

If[ShowLES,
(*Vector1Label=GenerateSequenceLabelExtended[
(*Heading Fancy*){Subscript["\[ScriptCapitalO]","S"],
(*Heading Standard*)"O_S"},
(*InList*){},(*Variety*)"S",(*Fancy*)FancyOutput,(*HeadingsOption*)HeadingsOption];*)
OSSimSjLabel=GenerateSequenceLabelExtended[
(*Heading Fancy*){Subsuperscript["\[CirclePlus]","i,j=1",lV]Subscript["\[ScriptCapitalO]","S"][Subscript[VbConstrString, "i"]-Subscript[VbConstrString, "j"]],
(*Heading Standard*)StringJoin["\\oplus_i,j O_S(",VbConstrString,"_i)-",VbConstrString,"_j)"]},
(*InList*)OSSimSjArray,(*Variety*)"S",(*Fancy*)FancyOutput,(*HeadingsOption*)HeadingsOption];
OSMixVdualLabel=GenerateSequenceLabelExtended[
(*Heading Fancy*){Subsuperscript["\[CirclePlus]","i=1",lV][Subscript["\[ScriptCapitalO]","S"][Subscript[VbConstrString,"i"]]]\[CircleTimes] Superscript[V,"*"],
(*Heading Standard*)StringJoin["O_S x ",ToString[V],"*"]},
(*InList*){},(*Variety*)"S",(*Fancy*)FancyOutput,(*HeadingsOption*)HeadingsOption];
ShowLongExactSequences=1,ShowLongExactSequences=0
];


OSMixVdual=ThirdVectorFromLongExactSequenceLabeled[
{OSSimSj,OSSimSjLabel},
{OSMixEdual,OSMixEdualLabel},
OSMixVdualLabel,
3,DimComplInters,{(*{2,0}*)}];(*Constraint for testing*)
(*Print["O_S(Si) x V* = ",OSMixVdual ];*)


(*gamma*)
If[ShowLES,
ExEdualLabel=GenerateSequenceLabelExtended[
(*Heading Fancy*){"\[ScriptCapitalE]"\[CircleTimes]Superscript["\[ScriptCapitalE]","*"],
(*Heading Standard*)"E x E*"},
(*InList*){},(*Variety*)"S",(*Fancy*)FancyOutput,(*HeadingsOption*)HeadingsOption];
ShowLongExactSequences=1,ShowLongExactSequences=0
];

Index++;
ExEdual=ThirdVectorFromLongExactSequenceLabeled[
{rOSxEdual,rOSxEdualLabel},
{OSNrxEdual,OSNrxEdualLabel},
ExEdualLabel,
3,DimComplInters,{}];(*Constraint for testing*)


If[SearchForTwisted==0,
(*Print["E x E* = ",ExEdual];*)
(*EdualxE={ExEdual[[4]],ExEdual[[3]],ExEdual[[2]],ExEdual[[1]],0,0};*)
EdualxE=Array[0&,Length[ExEdual]];
For[i=1,i<=DimComplInters+1,i++,
EdualxE[[i]]=ExEdual[[DimComplInters+1-(i-1)]]
];

(*Print["E* x E = ",EdualxE];*)
(*Use Serre dualit, namely h^p(ExEdual)=h^n-p(EdualxE)*)
(*Vector of parameters which will be constraint by altering sums in the long exact sequence*)
ParameterVector=Array[Subscript[A1, #-1]&,Length [EdualxE]];
(*This vector is for working and has therefore the same length of all the other vec4tors involved*)
WorkingVector=Array[Subscript[h1, #-1]&,Length [EdualxE]];
ExEdualSFT=ExEdual/.Pi->1;


(*Only resolve sequences if program does not collect line bundles*)
If[!LineBundleCollector[[1]]&&VectorBundleConstraints!={},
Solution={Reduce[WorkingVector -ExEdualSFT==0&& EdualxE==ExEdualSFT,WorkingVector]}/.(y__&&z__):>{y,z}/.(x_==y_):>(x->y);
If[Solution=={False},Print["\!\(\*
StyleBox[\"xxxxxxx\",\nFontColor->RGBColor[1, 0, 0]]\)\!\(\*
StyleBox[\" \",\nFontColor->RGBColor[1, 0, 0]]\)\!\(\*
StyleBox[\"Solution\",\nFontColor->RGBColor[1, 0, 0]]\)\!\(\*
StyleBox[\" \",\nFontColor->RGBColor[1, 0, 0]]\)\!\(\*
StyleBox[\"of\",\nFontColor->RGBColor[1, 0, 0]]\)\!\(\*
StyleBox[\" \",\nFontColor->RGBColor[1, 0, 0]]\)\!\(\*
StyleBox[\"EndV\",\nFontColor->RGBColor[1, 0, 0]]\)\!\(\*
StyleBox[\" \",\nFontColor->RGBColor[1, 0, 0]]\)\!\(\*
StyleBox[\"is\",\nFontColor->RGBColor[1, 0, 0]]\)\!\(\*
StyleBox[\" \",\nFontColor->RGBColor[1, 0, 0]]\)\!\(\*
StyleBox[\"inconsistent\",\nFontColor->RGBColor[1, 0, 0]]\)\!\(\*
StyleBox[\" \",\nFontColor->RGBColor[1, 0, 0]]\)\!\(\*
StyleBox[\"with\",\nFontColor->RGBColor[1, 0, 0]]\)\!\(\*
StyleBox[\" \",\nFontColor->RGBColor[1, 0, 0]]\)\!\(\*
StyleBox[\"Serre\",\nFontColor->RGBColor[1, 0, 0]]\)\!\(\*
StyleBox[\" \",\nFontColor->RGBColor[1, 0, 0]]\)\!\(\*
StyleBox[\"Duality\",\nFontColor->RGBColor[1, 0, 0]]\)\!\(\*
StyleBox[\"-\",\nFontColor->RGBColor[1, 0, 0]]\)\!\(\*
StyleBox[\" \",\nFontColor->RGBColor[1, 0, 0]]\)\!\(\*
StyleBox[\"Results\",\nFontColor->RGBColor[1, 0, 0]]\)\!\(\*
StyleBox[\" \",\nFontColor->RGBColor[1, 0, 0]]\)\!\(\*
StyleBox[\"may\",\nFontColor->RGBColor[1, 0, 0]]\)\!\(\*
StyleBox[\" \",\nFontColor->RGBColor[1, 0, 0]]\)\!\(\*
StyleBox[\"not\",\nFontColor->RGBColor[1, 0, 0]]\)\!\(\*
StyleBox[\" \",\nFontColor->RGBColor[1, 0, 0]]\)\!\(\*
StyleBox[\"be\",\nFontColor->RGBColor[1, 0, 0]]\)\!\(\*
StyleBox[\" \",\nFontColor->RGBColor[1, 0, 0]]\)\!\(\*
StyleBox[\"trustworthy\",\nFontColor->RGBColor[1, 0, 0]]\)\!\(\*
StyleBox[\" \",\nFontColor->RGBColor[1, 0, 0]]\)\!\(\*
StyleBox[\"xxxxxxx\",\nFontColor->RGBColor[1, 0, 0]]\)"];Solution={}];
(*If[Solution\[NotEqual]{False},*)
WorkingVector=Flatten[WorkingVector/.Solution];
ExEdual=WorkingVector;(*else*)

];
];


(*beta*)
If[ShowLES,
ExVdualLabel=GenerateSequenceLabelExtended[
(*Heading Fancy*){"\[ScriptCapitalE]"\[CircleTimes]Superscript[V,"*"],
(*Heading Standard*)StringJoin["E x ",ToString[V],"*"]},
(*InList*){},(*Variety*)"S",(*Fancy*)FancyOutput,(*HeadingsOption*)HeadingsOption];
ShowLongExactSequences=1,ShowLongExactSequences=0
];

ExVdual=ThirdVectorFromLongExactSequenceLabeled[
{ExOSmMi,ExOSmMiLabel},
{ExEdual,ExEdualLabel},
ExVdualLabel,
3,DimComplInters,{(*{2,0}*)}];(*Constraint for testing*)
(*Print["E x V* = ",ExVdual];*)

(*alpha*)
If[ShowLES,
VxVdualLabel=GenerateSequenceLabelExtended[
(*Heading Fancy*){V\[CircleTimes]Superscript[V,"*"],
(*Heading Standard*)StringJoin[ToString[V]," x ",ToString[V],"*"]},
(*InList*){},(*Variety*)"S",(*Fancy*)FancyOutput,(*HeadingsOption*)HeadingsOption];
ShowLongExactSequences=1,ShowLongExactSequences=0
];

VxVdual=ThirdVectorFromLongExactSequenceLabeled[
{ExVdual,ExVdualLabel},
{OSMixVdual,OSMixVdualLabel},
VxVdualLabel,
1,DimComplInters,{{1,1},{DimComplInters+1,1}}];(*condition that the bundle is stable is included meaning h^0=h^dim=1*)
(*Print["V x V* = ",VxVdual];*)

ReturnCohomology=VxVdual[[1;;DimComplInters+1]];

PrintCohomology=Text@Grid[Prepend[Transpose[{ReturnCohomology}],{Superscript["h","\[Bullet]"][ V\[CircleTimes]Superscript[V,"*"] ]}],Background->{None,{Lighter[Yellow,.9],{White,Lighter[Blend[{Blue,Green}],.8]}}},Dividers->{{Darker[Gray,.6],{Lighter[Gray,.5]},Darker[Gray,.6]},{Darker[Gray,.6],Darker[Gray,.6],{False},Darker[Gray,.6]}},Alignment->{Center},(*ItemSize\[Rule]{{10,3,5,5}},*)Frame->Darker[Gray,.6],ItemStyle->14,Spacings->{Automatic,.8}]
];
(*Implement the spectral sequence from (0,2) elephant paper*)

If[BundleType=="SpectralSequence",
KoszuledLineBundleList={{1}};
(*Check for correct input data*)
CheckData=CheckInputData[AmbientSpace,ComplInters,Type];
If[!CheckData[[1]],Return[CheckData[[2]]]];

Index=1;
(*LineBundleCounter={0,0};*)
DimAmbientSpace=Length[AmbientSpace[[1]]]-Length[AmbientSpace[[3,1]]];
DimComplInters=DimAmbientSpace-Length[ComplInters];
r=Length[AmbientSpace[[3,1]]];
Print[]

];


If[ReturnCohomology!={},
If[!HodgeCalculation,
If[VerboseLevel==-1,Return[ReturnCohomology]];
LateTime=DateList[];
Stats=StringJoin["Calculation of ",BundleType," cohomology done:\n",
"-----------------------------------------------\n",
"Total number of line bundles:  ", ToString[LineBundleCounter[[2]]],"\n",
"Newly computed:                " ,ToString[LineBundleCounter[[1]]],"\n",
"Total time needed:             ",ToString[Round[AbsoluteTime[LateTime]-AbsoluteTime[EarlyTime],0.001]]," seconds"];
If[FancyOutput==1,
(*PrintCohomology=Style[PrintCohomology,FontSize\[Rule]LESFontSize];*)
Print[TableForm[{cohomCalgLogo,Stats,PrintCohomology},TableDirections->Row,TableAlignments->Center]],
Print[Stats];
];
If[FancyOutput==1,Return[]];
];
Return[ReturnCohomology];
,
(*In case the typed bundle is not in list*)
Return["Error: Unknown bundle type."]
];
];




