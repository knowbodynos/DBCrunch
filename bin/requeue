#!/bin/bash

do_requeue () {
    modpath=$1
    controllerpath=$2
    workpath=$3

    #loadfilenames=$(find ${mainpath}/jobs/ -maxdepth 1 -type f -name "*.docs" | rev | cut -d'/' -f1 | rev | tr '\n' ',')
    loadfilenames=$(find ${workpath} -maxdepth 1 -path '*/.*' -prune -o -type f -name "*.docs" -print 2>/dev/null | rev | cut -d'/' -f1 | rev)
    #loadfilejobpatt=$(echo ${loadfilenames} | tr ',' '\n' | sed 's/\(.*_job_[0-9]*\).*/\1/g' | sort -u)
    #mkdir ${mainpath}/jobs/requeued 2>/dev/null
    #for patt in ${loadfilejobpatt}
    #do
    #    mv ${mainpath}/jobs/${patt}* ${mainpath}/jobs/requeued/ 2>/dev/null
    #done
    #for loadfilename in $(echo ${loadfilenames} | tr ',' '\n')
    for loadfilename in ${loadfilenames}
    do
        if [ -s "${loadfilename/.docs/.err}" ]
        then
            #errcode=$(cat ${mainpath}/jobs/requeued/${loadfilename/.docs/.out} | grep "ExitCode: " | cut -d' ' -f2)
            errcode=$(cat ${workpath}/${loadfilename/.docs/.err} | grep "ExitCode: " | cut -d' ' -f2)
            if [[ "${errcode}" == "" ]]
            then
                errcode="-1:0"
            fi
        else
            errcode="-1:0"
        fi
        echo "${loadfilename},${errcode},True"
    done >> ${controllerpath}/skipped

    echo "Finished requeuing ${modname}_${controllername}."
}

do_not_dir() {
    path=$1
}

modules_dir=$1
shift

startpath=$(cd ${modules_dir} && pwd -P)

branches=$(find ${startpath} -path '*/.*' -prune -o -type d -exec bash -c 'echo "$(echo '{}' 2>/dev/null | sed "s/\/jobs\$//g" | grep -o / | wc -l) $(echo '{}' 2>/dev/null | sed "s/\/jobs\$//g")"' \; | grep -v '/jobs/' | sort -u | tr '\n' ',')
maxdepth=$(echo ${branches} | tr ',' '\n' | cut -d' ' -f1 | sort -u | tail -n1)
leaves=$(echo ${branches} | tr ',' '\n' | grep "^${maxdepth} " | cut -d' ' -f2 | sed 's/\/jobs$//g' | tr '\n' ',')
moddirpath=$(echo ${leaves} | tr ',' '\n' | rev | cut -d'/' -f1,2 --complement | rev | head -n1)
modnames=($(echo ${leaves} | tr ',' '\n' | rev | cut -d'/' -f2 | rev))
controllernames=($(echo ${leaves} | tr ',' '\n' | rev | cut -d'/' -f1 | rev))

case $# in
    0)
        ;;
    1)
        if [[ "${moddirpath}" == "${startpath}" ]]
        then
            modnames=($1)
            controllernames=()
        else
            stopflag=false
            for i in ${!controllernames[@]}
            do
                if [[ "${controllernames[${i}]}" == "$1" ]]
                then
                    modnames=(${modnames[${i}]})
                    controllernames=(${controllernames[i]})
                    stopflag=true
                    break
                fi
            done
            if ! ${stopflag}
            then
                for modname in ${modnames[@]}
                do
                    if [[ "${modname}" == "$1" ]]
                    then
                        modnames=(${modname})
                        controllernames=()
                        stopflag=true
                        break
                    fi
                done
            fi
            if ! ${stopflag}
            then
                for modname in $(find ${moddirpath} -mindepth 1 -maxdepth 1 -path '*/.*' -prune -o -type d -print 2>/dev/null | rev | cut -d'/' -f1 | rev)
                do
                    if [[ "${modname}" == "$1" ]]
                    then
                        modnames=(${modname})
                        controllernames=()
                        stopflag=true
                        break
                    fi
                done
            fi
            if ! ${stopflag}
            then
                for i in ${!modnames[@]}
                do
                    modnames=(${modnames[${i}]})
                    controllernames=($1)
                done
            fi
        fi
        ;;
    2)
        modnames=($1)
        controllernames=($2)
        ;;
    *)
        echo "Error: You must provide no more than 2 arguments. $# provided."
        exit
        ;;
esac

for i in ${!modnames[@]}
do
    modname=${modnames[${i}]}

    modpath="${moddirpath}/${modname}"

    if [ ! -d "${modpath}" ]
    then
        do_not_dir ${modpath}
    fi

    if [[ "${controllernames[${i}]}" == "" ]]
    then
        controllernames=($(find ${modpath} -mindepth 1 -maxdepth 1 -path '*/.*' -prune -o -type d -print 2>/dev/null | rev | cut -d'/' -f1 | rev))

        for controllername in ${controllernames[@]}
        do
            controllerpath="${modpath}/${controllername}"

            if [ ! -d "${controllerpath}" ]
            then
                do_not_dir ${controllerpath}
            fi

            workpath="${controllerpath}/jobs"

            if [ ! -d "${workpath}" ]
            then
                do_not_dir ${workpath}
            fi

            if [ -d "${modpath}" ] && [ -d "${controllerpath}" ] && [ -d "${workpath}" ]
            then
                do_requeue ${modpath} ${controllerpath} ${workpath}
            fi
        done
    else
        controllername=${controllernames[${i}]}
        controllerpath="${modpath}/${controllername}"

        if [ ! -d "${controllerpath}" ]
        then
            do_not_dir ${controllerpath}
        fi

        workpath="${controllerpath}/jobs"

        if [ ! -d "${workpath}" ]
        then
            do_not_dir ${workpath}
        fi

        if [ -d "${modpath}" ] && [ -d "${controllerpath}" ] && [ -d "${workpath}" ]
        then
            do_requeue ${modpath} ${controllerpath} ${workpath}
        fi
    fi
done