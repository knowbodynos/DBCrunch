#!/bin/bash

do_create() {
    is_create=$1
    path=$2

    if ${is_create}
    then
        mkdir ${path}
    fi
}

run_subcommand() {
    scriptpath=$1
    shift

    is_create=$1
    shift

    modules_dir=$1
    shift

    startpath=$(cd ${modules_dir} && pwd -P)

    currdir=${startpath}

    module_paths=($(find ${currdir} -mindepth 1 -type d -path '*/.*' -prune -o -type f -name '.DBCrunch' -execdir pwd -P \;))

    currdir=$(cd ${currdir}/.. && pwd -P)
    dirstats=$(stat -c '%a %U' ${currdir})
    while [[ "${dirstats}" =~ ^"777 " ]] || [[ "${dirstats}" =~ " ${USER}"$ ]]
    do
        if [ -f "${currdir}/.DBCrunch" ]
        then
            module_paths=("${currdir}" "${module_paths[@]}")
        fi
        currdir=$(cd ${currdir}/.. && pwd -P)
        dirstats=$(stat -c '%a %U' ${currdir})
    done

    if [ "${#module_paths[@]}" -eq 0 ]
    then
        echo "Error: No module path detected."
        exit 1
    elif [ "${#module_paths[@]}" -gt 1 ]
    then
        echo "Error: Multiple module paths detected. Please choose one:"
        for i in ${!module_paths[@]}
        do
            echo "  ${i}) ${module_paths[${i}]}"
        done
        exit 1
    fi

    moddirpath=${module_paths[0]}
    pathdiff=${startpath##${moddirpath}/}
    if [[ "${pathdiff}" == "${startpath}" ]]
    then
        pathdiff=""
    fi
    read modname controllername <<< $(echo ${pathdiff} | sed 's/\// /g' | cut -d' ' -f1,2)

    case $# in
        0)
            if [[ "${modname}" != "" ]]
            then
                if [[ "${controllername}" != "" ]] && [ -d "${moddirpath}/${modname}/${controllername}" ]
                then
                    modnames=(${modname})
                    controllernames=(${controllername})
                else
                    modnames=(${modname})
                    controllernames=($(find ${moddirpath}/${modname} -mindepth 1 -maxdepth 1 -type d -path '*/.*' -prune -o -type d -print 2>/dev/null | rev | cut -d'/' -f1 | rev))
                fi
            else
                modnames=($(find ${moddirpath} -mindepth 1 -maxdepth 1 -type d -path '*/.*' -prune -o -type d -print 2>/dev/null | rev | cut -d'/' -f1 | rev))
                controllernames=()
            fi
            #modnames=(${modname})
            #controllernames=(${controllername})
            ;;
        1)
            case $1 in
                ${modname} | ${controllername})
                    modnames=(${modname})
                    controllernames=(${controllername})
                    ;;
                *)
                    if [[ "${modname}" != "" ]]
                    then
                        if [ -d "${moddirpath}/${modname}/$1" ]
                        then
                            modnames=(${modname})
                            controllernames=($1)
                        else
                            if ${is_create}
                            then
                                modnames=(${modname})
                                controllernames=($1)
                            else
                                modnames=($1)
                                controllernames=()
                            fi
                        fi
                    else
                        modnames=($1)
                        controllernames=()
                    fi
                    ;;
            esac
            shift
            ;;
        *)
            modnames=($1)
            controllernames=($2)
            shift
            shift
            ;;
        #*)
        #    echo "Error: You must provide no more than 2 arguments. $# provided."
        #    exit 1
        #    ;;
    esac

    for i in ${!modnames[@]}
    do
        modname=${modnames[${i}]}

        modpath="${moddirpath}/${modname}"

        if [ ! -d "${modpath}" ] && ${is_create}
        then
            do_create ${is_create} ${modpath}
        fi

        if [[ "${controllernames[${i}]}" == "" ]]
        then
            controllernames=($(find ${modpath} -mindepth 1 -maxdepth 1 -type d -path '*/.*' -prune -o -type d -print 2>/dev/null | rev | cut -d'/' -f1 | rev))

            for controllername in ${controllernames[@]}
            do
                controllerpath="${modpath}/${controllername}"

                if [ ! -d "${controllerpath}" ] && ${is_create}
                then
                    do_create ${is_create} ${controllerpath}
                fi

                #workpath="${controllerpath}/jobs"

                #if [ ! -d "${workpath}" ] && ${is_create}
                #then
                #    do_create ${is_create} ${workpath}
                #fi

                #${scriptpath} ${modpath} ${controllerpath} ${workpath} ${@}
                ${scriptpath} ${modpath} ${controllerpath} ${@}
            done
        else
            controllername=${controllernames[${i}]}
            controllerpath="${modpath}/${controllername}"

            if [ ! -d "${controllerpath}" ] && ${is_create}
            then
                do_create ${is_create} ${controllerpath}
            fi

            #workpath="${controllerpath}/jobs"

            #if [ ! -d "${workpath}" ] && ${is_create}
            #then
            #    do_create ${is_create} ${workpath}
            #fi

            #${scriptpath} ${modpath} ${controllerpath} ${workpath} ${@}
            ${scriptpath} ${modpath} ${controllerpath} ${@}
        fi
    done
}

ProgName=$(basename "${BASH_SOURCE[0]}")
ProgDir=$(cd $(dirname "${BASH_SOURCE[0]}"); pwd -P)
  
sub_help(){
    echo "Usage: $ProgName [<$ProgName options>] [<subcommand>] [<subcommand options>] [module_name/controller_name] [controller_name]\n"
    echo ""
    echo "$ProgName Options:"
    echo "    --modules-dir [<dir>]            Specify a working directory other than the current one"
    echo ""
    echo "Subcommands:"
    echo "    analyze                          Analyze resource usage statistics"
    echo "    cancel                           Cancel module or controller jobs"
    echo "    create                           Create new controller job file for a module from a config file"
    echo "    monitor                          Monitor all controller jobs"
    echo "        monitor Subcommands:"
    echo "            [<integer>]              Refresh interval (seconds)"
    echo "    plot                             Plot controller jobs steps"
    echo "    requeue                          Requeue jobs skipped by controller"
    echo "    reset                            Reset controller for a module"
    echo "    submit                           Submit controller batch job"
    echo "    template                         Create new controller job file for a module from a template"
    echo "    test                             Test what modules and controllers are matched"
    echo "        test Subcommands:"
    echo "            [<boolean>]              Create directory (true/false)"
    echo ""
    #echo "For help with each subcommand run:"
    #echo "$ProgName <subcommand> -h|--help"
    #echo ""
}

sub_analyze(){
    is_create=false
    run_subcommand ${ProgDir}/analyze ${is_create} ${@}
}

sub_cancel(){
    is_create=false
    run_subcommand ${ProgDir}/cancel ${is_create} ${@}
}

sub_create(){
    is_create=false
    run_subcommand ${ProgDir}/create ${is_create} ${@}
}

sub_monitor(){
    if [ "$#" -eq 1 ]
    then
        ${ProgDir}/monitor 1
    else
        ${ProgDir}/monitor $2
    fi
}

sub_plot(){
    is_create=false
    run_subcommand ${ProgDir}/plot ${is_create} ${@}
}

sub_requeue(){
    is_create=false
    run_subcommand ${ProgDir}/requeue ${is_create} ${@}
}

sub_reset(){
    is_create=false
    run_subcommand ${ProgDir}/reset ${is_create} ${@}
}

sub_submit(){
    is_create=false
    run_subcommand ${ProgDir}/submit ${is_create} ${@}
}

sub_template(){
    is_create=true
    run_subcommand ${ProgDir}/template ${is_create} ${@}
}

sub_test(){
    modules_dir=$1
    is_create=$2
    shift 2
    run_subcommand ${ProgDir}/test ${is_create} ${modules_dir} ${@}
}

subcommand_arr=("analyze" "cancel" "create" "monitor" "plot" "requeue" "reset" "submit" "template" "test")

i=0
flag=false
while [ "${i}" -le "$#" ] && ! ${flag}
do
    for x in ${subcommand_arr[@]}
    do
        if [ "${!i}" == "${x}" ]
        then
            flag=true
            break
        fi
    done
    i=$((${i}+1))
done

mainargs="${@:0:$((${i}-1))}"
subcommand="${@:$((${i}-1)):1}"
subargs="${@:${i}}"

SHORTOPTS="m:" 
LONGOPTS="modules-dir:"

ARGS=$(getopt -s bash --options $SHORTOPTS --longoptions $LONGOPTS -- "${mainargs}")

eval set -- "$ARGS"

modules_dir=$(pwd -P)

while true
do
    case $1 in
        -m | --modules-dir)
            modules_dir=$2
            shift 2
            ;;
        --)
            shift
            break 
            ;;
        *)
            echo "$1 is not a valid option."
            exit 1
            ;;
    esac
done

if [ ! -d "${modules_dir}" ]
then
    echo "Error: Directory \"${modules_dir}\" does not exist."
    exit 1
fi
  
#subcommand=$1
case $subcommand in
    "-h" | "--help")
        sub_help
        ;;
    *)
        shift
        sub_${subcommand} ${modules_dir} ${subargs}
        if [ $? = 127 ]; then
            echo "Error: '$subcommand' is not a known subcommand." >&2
            echo "       Run '$ProgName --help' for a list of known subcommands." >&2
            exit 1
        fi
        ;;
esac